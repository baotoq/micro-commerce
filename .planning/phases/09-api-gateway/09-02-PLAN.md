---
phase: 09-api-gateway
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/MicroCommerce.Gateway/Program.cs
  - src/MicroCommerce.Gateway/appsettings.json
  - src/MicroCommerce.Gateway/MicroCommerce.Gateway.csproj
  - src/MicroCommerce.ApiService/Program.cs
autonomous: true

must_haves:
  truths:
    - "Invalid/expired JWT is rejected with 401 at the gateway before reaching ApiService"
    - "Unauthenticated requests to protected routes (ordering, messaging, catalog writes) get 401"
    - "Public routes (GET catalog, cart, GET inventory) work without authentication"
    - "Rate-limited client receives 429 response with Retry-After header"
    - "Authenticated users get higher rate limit (100/min) than anonymous (30/min)"
    - "CORS preflight requests succeed for allowed origins"
    - "X-Request-ID header is added to proxied requests for distributed tracing"
    - "CORS configuration removed from ApiService (centralized in gateway)"
  artifacts:
    - path: "src/MicroCommerce.Gateway/Program.cs"
      provides: "Full middleware pipeline: CORS, rate limiter, auth, authz, reverse proxy"
      contains: "UseRateLimiter"
    - path: "src/MicroCommerce.Gateway/appsettings.json"
      provides: "Route-level authorization policies (public vs authenticated)"
      contains: "AuthorizationPolicy"
  key_links:
    - from: "src/MicroCommerce.Gateway/Program.cs"
      to: "Keycloak"
      via: "JWT Bearer authentication"
      pattern: "AddKeycloakJwtBearer|AddJwtBearer"
    - from: "src/MicroCommerce.Gateway/Program.cs"
      to: "Rate limiter"
      via: "Partitioned sliding window"
      pattern: "SlidingWindowRateLimiter"
    - from: "src/MicroCommerce.Gateway/appsettings.json"
      to: "Route authorization"
      via: "Per-route AuthorizationPolicy"
      pattern: "AuthorizationPolicy"
---

<objective>
Add JWT authentication, authorization policies, rate limiting, CORS, and request transforms to the gateway. Remove CORS from ApiService to centralize it at the gateway level.

Purpose: Enforces security at the single entry point — invalid JWTs rejected before reaching backend, rate limiting protects against abuse, CORS centralized for consistency.
Output: Gateway with full middleware pipeline (CORS -> RateLimiter -> Auth -> AuthZ -> ReverseProxy) and ApiService CORS removed.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-api-gateway/09-01-SUMMARY.md
@.planning/phases/09-api-gateway/09-RESEARCH.md

@src/MicroCommerce.ApiService/Program.cs
@src/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
@src/MicroCommerce.ApiService/Features/Cart/CartEndpoints.cs
@src/MicroCommerce.ApiService/Features/Ordering/OrderingEndpoints.cs
@src/MicroCommerce.ApiService/Features/Inventory/InventoryEndpoints.cs
@src/MicroCommerce.ApiService/Features/Messaging/MessagingEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JWT auth, rate limiting, CORS, and request transforms to gateway</name>
  <files>
    src/MicroCommerce.Gateway/Program.cs
    src/MicroCommerce.Gateway/appsettings.json
    src/MicroCommerce.Gateway/MicroCommerce.Gateway.csproj
  </files>
  <action>
    **MicroCommerce.Gateway.csproj:**
    - Add package reference: `Keycloak.AuthServices.Authentication` (same package ApiService uses for `AddKeycloakJwtBearer`)
    - Check ApiService.csproj for the exact version of this package and match it

    **Program.cs — Update to add full middleware pipeline:**

    1. **JWT Authentication** — Use `AddKeycloakJwtBearer` matching ApiService pattern:
       ```csharp
       builder.Services.AddAuthentication()
           .AddKeycloakJwtBearer(
               serviceName: "keycloak",
               realm: "micro-commerce",
               options =>
               {
                   options.TokenValidationParameters.ValidateAudience = false;
                   if (builder.Environment.IsDevelopment())
                   {
                       options.RequireHttpsMetadata = false;
                   }
               });
       ```
       - Gateway needs `.WithReference(keycloak)` in AppHost for service discovery — add this to the gateway resource in AppHost.cs

    2. **Authorization policies:**
       ```csharp
       builder.Services.AddAuthorizationBuilder()
           .AddPolicy("authenticated", policy => policy.RequireAuthenticatedUser());
       ```

    3. **CORS policy** — Centralized, moved from ApiService:
       ```csharp
       builder.Services.AddCors(options =>
       {
           options.AddDefaultPolicy(policy =>
           {
               policy.WithOrigins("http://localhost:3000", "http://localhost:3001")
                   .AllowAnyHeader()
                   .AllowAnyMethod()
                   .AllowCredentials();
           });
       });
       ```

    4. **Rate limiting** — Partitioned sliding window (authenticated 100/min, anonymous 30/min):
       ```csharp
       builder.Services.AddRateLimiter(options =>
       {
           options.OnRejected = async (context, token) =>
           {
               context.HttpContext.Response.StatusCode = 429;
               if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter))
               {
                   context.HttpContext.Response.Headers.RetryAfter =
                       ((int)retryAfter.TotalSeconds).ToString();
               }
               await context.HttpContext.Response.WriteAsync("Too many requests", token);
           };

           options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(httpContext =>
           {
               var userName = httpContext.User.Identity?.Name;
               return string.IsNullOrEmpty(userName)
                   ? RateLimitPartition.GetSlidingWindowLimiter(
                       httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
                       _ => new SlidingWindowRateLimiterOptions
                       {
                           PermitLimit = 30,
                           Window = TimeSpan.FromMinutes(1),
                           SegmentsPerWindow = 6,
                           QueueLimit = 0
                       })
                   : RateLimitPartition.GetSlidingWindowLimiter(userName, _ =>
                       new SlidingWindowRateLimiterOptions
                       {
                           PermitLimit = 100,
                           Window = TimeSpan.FromMinutes(1),
                           SegmentsPerWindow = 6,
                           QueueLimit = 0
                       });
           });
       });
       ```

    5. **YARP with X-Request-ID transform** — Update the existing `AddReverseProxy()` call:
       ```csharp
       builder.Services.AddReverseProxy()
           .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"))
           .AddTransforms(context =>
           {
               context.AddRequestTransform(transformContext =>
               {
                   if (!transformContext.HttpContext.Request.Headers.ContainsKey("X-Request-ID"))
                   {
                       transformContext.ProxyRequest.Headers.Add(
                           "X-Request-ID",
                           Activity.Current?.Id ?? Guid.NewGuid().ToString());
                   }
                   return ValueTask.CompletedTask;
               });
           });
       ```
       - Add `using System.Diagnostics;` for `Activity.Current`

    6. **Middleware pipeline ORDER MATTERS:**
       ```csharp
       app.UseCors();
       app.UseRateLimiter();
       app.UseAuthentication();
       app.UseAuthorization();
       app.MapReverseProxy();
       app.MapDefaultEndpoints();
       app.Run();
       ```

    **appsettings.json — Add per-route authorization policies:**

    Replace the single catch-all route with granular routes that specify authorization policies based on existing ApiService endpoint auth patterns:

    Route analysis from existing endpoints:
    - **Catalog GET** (products, categories): No `.RequireAuthorization()` on group — PUBLIC
    - **Catalog writes** (POST/PUT/DELETE/PATCH products, categories, images): No explicit auth on group but these are admin operations — mark as AUTHENTICATED
    - **Inventory GET** (stock levels, adjustments): No `.RequireAuthorization()` — PUBLIC
    - **Inventory writes** (adjust, reserve, release): Internal/admin operations — mark as AUTHENTICATED
    - **Cart** (all operations): No `.RequireAuthorization()`, uses cookie-based BuyerIdentity — PUBLIC (guest access)
    - **Ordering** (all operations): No `.RequireAuthorization()` on group, but uses BuyerIdentity — PUBLIC (guest checkout supported)
    - **Messaging** (DLQ): `.RequireAuthorization()` on group — AUTHENTICATED

    Configure routes in appsettings.json:
    ```json
    {
      "ReverseProxy": {
        "Routes": {
          "catalog-read": {
            "ClusterId": "apiservice",
            "Match": {
              "Path": "/api/catalog/{**catch-all}",
              "Methods": ["GET"]
            }
          },
          "catalog-write": {
            "ClusterId": "apiservice",
            "AuthorizationPolicy": "authenticated",
            "Match": {
              "Path": "/api/catalog/{**catch-all}",
              "Methods": ["POST", "PUT", "DELETE", "PATCH"]
            }
          },
          "inventory-read": {
            "ClusterId": "apiservice",
            "Match": {
              "Path": "/api/inventory/{**catch-all}",
              "Methods": ["GET"]
            }
          },
          "inventory-write": {
            "ClusterId": "apiservice",
            "AuthorizationPolicy": "authenticated",
            "Match": {
              "Path": "/api/inventory/{**catch-all}",
              "Methods": ["POST", "DELETE"]
            }
          },
          "cart": {
            "ClusterId": "apiservice",
            "Match": {
              "Path": "/api/cart/{**catch-all}"
            }
          },
          "ordering": {
            "ClusterId": "apiservice",
            "Match": {
              "Path": "/api/ordering/{**catch-all}"
            }
          },
          "messaging": {
            "ClusterId": "apiservice",
            "AuthorizationPolicy": "authenticated",
            "Match": {
              "Path": "/api/messaging/{**catch-all}"
            }
          }
        },
        "Clusters": {
          "apiservice": {
            "Destinations": {
              "default": {
                "Address": "https+http://apiservice"
              }
            }
          }
        }
      }
    }
    ```

    **AppHost.cs — Add keycloak reference to gateway:**
    Update the gateway resource to include `.WithReference(keycloak)` so the gateway can resolve the Keycloak issuer URL for JWT validation:
    ```csharp
    var gateway = builder.AddProject<Projects.MicroCommerce_Gateway>("gateway")
        .WithReference(apiService)
        .WithReference(keycloak)
        .WithHttpHealthCheck("/health");
    ```

    **Required using statements for Program.cs:**
    - `using System.Diagnostics;`
    - `using System.Threading.RateLimiting;`
    - `using Microsoft.AspNetCore.RateLimiting;` (for `MetadataName`)
  </action>
  <verify>
    Run `dotnet build src/MicroCommerce.Gateway/MicroCommerce.Gateway.csproj` — zero errors.
    Run `dotnet build src/MicroCommerce.AppHost/MicroCommerce.AppHost.csproj` — zero errors.
    Grep Program.cs for: `UseCors`, `UseRateLimiter`, `UseAuthentication`, `UseAuthorization`, `MapReverseProxy` — all present in correct order.
    Grep appsettings.json for `AuthorizationPolicy` — present on catalog-write, inventory-write, and messaging routes.
  </verify>
  <done>Gateway has JWT validation (Keycloak), partitioned rate limiting (30/100 req/min), CORS, X-Request-ID transform, and per-route authorization policies. Middleware pipeline in correct order.</done>
</task>

<task type="auto">
  <name>Task 2: Remove CORS from ApiService (centralized in gateway)</name>
  <files>
    src/MicroCommerce.ApiService/Program.cs
  </files>
  <action>
    Remove the CORS configuration from ApiService Program.cs since it is now centralized at the gateway level.

    **Remove these lines from Program.cs:**
    1. The `builder.Services.AddCors(...)` block (lines ~127-136):
       ```csharp
       builder.Services.AddCors(options =>
       {
           options.AddDefaultPolicy(policy =>
           {
               policy.WithOrigins("http://localhost:3000", "http://localhost:3001")
                   .AllowAnyHeader()
                   .AllowAnyMethod()
                   .AllowCredentials();
           });
       });
       ```
    2. The `app.UseCors();` call in the middleware pipeline

    **Keep everything else exactly as-is** — authentication, authorization, exception handling, module registrations, endpoints. The backend still needs its own auth middleware for claim extraction (BuyerIdentity pattern).

    **Why remove CORS from ApiService:** Per context decision, CORS is centralized at the gateway. With the gateway as the single entry point, the browser's CORS preflight requests hit the gateway (which allows them), then the gateway proxies to ApiService on the backend network where CORS is not needed.
  </action>
  <verify>
    Run `dotnet build src/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` — zero errors.
    Grep ApiService Program.cs for `AddCors` — should NOT be found.
    Grep ApiService Program.cs for `UseCors` — should NOT be found.
    Grep ApiService Program.cs for `UseExceptionHandler` — should still be present (not accidentally removed).
  </verify>
  <done>CORS removed from ApiService. ApiService still has authentication/authorization middleware for claim extraction. Gateway is the single CORS enforcement point.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/MicroCommerce.Gateway/MicroCommerce.Gateway.csproj` — zero errors
2. `dotnet build src/MicroCommerce.AppHost/MicroCommerce.AppHost.csproj` — zero errors
3. `dotnet build src/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` — zero errors
4. Gateway Program.cs middleware order: UseCors -> UseRateLimiter -> UseAuthentication -> UseAuthorization -> MapReverseProxy
5. Gateway has JWT auth via AddKeycloakJwtBearer with matching ApiService config
6. Gateway has partitioned rate limiter (30 anonymous, 100 authenticated per minute)
7. Gateway has X-Request-ID transform
8. Gateway routes: catalog-read (public), catalog-write (auth), inventory-read (public), inventory-write (auth), cart (public), ordering (public), messaging (auth)
9. ApiService no longer has CORS configuration
</verification>

<success_criteria>
- JWT validation configured at gateway with Keycloak service discovery
- Rate limiting with sliding window: 30/min anonymous, 100/min authenticated, 429 + Retry-After
- CORS centralized at gateway, removed from ApiService
- Per-route authorization policies match existing endpoint auth patterns
- X-Request-ID added to proxied requests
- Middleware pipeline in correct order
- All projects build cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/09-api-gateway/09-02-SUMMARY.md`
</output>
