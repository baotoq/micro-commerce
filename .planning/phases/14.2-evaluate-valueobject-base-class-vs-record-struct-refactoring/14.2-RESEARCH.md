# Phase 14.2: Evaluate ValueObject base class vs record struct refactoring - Research

**Researched:** 2026-02-14
**Domain:** C# value object implementation patterns, DDD tactical patterns, EF Core value type mapping
**Confidence:** HIGH

## Summary

The codebase already demonstrates **inconsistent value object implementation**: older modules (Catalog, Cart, Inventory, Profiles) use the abstract `ValueObject` base class, while newer modules (Ordering, Reviews) use `record` classes. The `ValueObject.cs` file itself recommends `readonly record struct` for most cases in C# 10+.

**Current state analysis:**
- 5 value objects use `ValueObject` base class: Money, ProductName, CategoryName, Quantity, DisplayName
- 3 value objects use `record class`: Rating, ReviewText, ShippingAddress
- 13 strongly-typed IDs use `record` (inheriting from `StronglyTypedId<T>`)
- 1 critical issue: Address inherits from ValueObject but has identity (AddressId) + mutators, violating value object principles

**Primary recommendation:** Standardize on `readonly record struct` for simple value objects with EF Core 8+ ComplexProperty support, retain `record class` for value objects requiring custom equality semantics or used in OwnsMany collections, and eliminate the `ValueObject` base class for new code. Migration should be incremental due to EF Core mapping changes.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| C# 13 | .NET 10 | Language features | Positional record structs, primary constructors, readonly struct enforcement |
| EF Core 10 | Latest | ORM with value object support | ComplexProperty for structs (EF 8+), OwnsOne/OwnsMany for reference types |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Ardalis.GuardClauses | Current | Input validation | Factory method validation (used in existing VOs) |
| System.Text.Json | .NET 10 | Serialization | All record types serialize without custom converters |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `readonly record struct` | `ValueObject` base class | Base class: explicit domain modeling, custom equality control, ORM overhead vs struct: performance, immutability by design, no custom equality |
| `readonly record struct` | `record class` | Class: works with OwnsMany collections, heap allocation vs struct: stack allocation, collection limitations |
| `record` equality | Manual `GetEqualityComponents()` | Record: compiler-generated, all properties vs Manual: exclude properties, custom precision (e.g., float rounding) |

**Installation:**
```bash
# No additional packages needed - language and framework features
```

## Architecture Patterns

### Recommended Value Object Types Matrix

| Value Object Type | Implementation | EF Core Mapping | When to Use |
|------------------|----------------|----------------|-------------|
| **Simple single-value** | `readonly record struct` | ComplexProperty | Money, ProductName, CategoryName, Quantity, DisplayName |
| **Multi-property immutable** | `readonly record struct` | ComplexProperty (EF 8+) | ShippingAddress (if not in collection) |
| **Custom equality needed** | `record class` with overrides | OwnsOne | Money (if comparing amounts with precision tolerance) |
| **Collection item** | `record class` OR entity | OwnsMany (requires key) | Address (current issue - has identity) |
| **Strongly-typed ID** | `record` inheriting `StronglyTypedId<T>` | HasConversion | ProductId, OrderId, etc. (already standard) |

### Pattern 1: Simple Value Object (readonly record struct)
**What:** Immutable value type with structural equality, no custom comparison
**When to use:** Single-value or multi-property value objects without collection semantics
**Example:**
```csharp
// Source: C# 13 positional record struct pattern
namespace MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;

/// <summary>
/// Value object representing a monetary amount with currency.
/// </summary>
public readonly record struct Money
{
    public decimal Amount { get; init; }
    public string Currency { get; init; }

    private Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    public static Money Create(decimal amount, string currency = "USD")
    {
        Guard.Against.Negative(amount, nameof(amount));
        Guard.Against.NullOrWhiteSpace(currency, nameof(currency));

        return new Money(amount, currency.ToUpperInvariant());
    }

    public override string ToString() => $"{Currency} {Amount:F2}";
}

// EF Core 8+ mapping
builder.ComplexProperty(p => p.Price, money =>
{
    money.Property(m => m.Amount).HasColumnName("Price").HasPrecision(18, 2);
    money.Property(m => m.Currency).HasColumnName("Currency").HasMaxLength(3);
});
```

### Pattern 2: Value Object with Custom Equality (record class)
**What:** Reference type with manual equality override for precise control
**When to use:** Need to exclude properties from equality or apply custom comparison logic
**Example:**
```csharp
// Source: Enterprise Craftsmanship - C# Records as DDD Value Objects
public sealed record CustomerStatus
{
    public bool IsAdvanced { get; init; }
    public DateTime? ExpirationDate { get; init; }

    private CustomerStatus() { }

    public static CustomerStatus CreateRegular() => new();

    public static CustomerStatus CreateAdvanced(DateTime expirationDate)
    {
        if (expirationDate <= DateTime.UtcNow)
            throw new ArgumentException("Expiration must be in future");
        return new CustomerStatus { IsAdvanced = true, ExpirationDate = expirationDate };
    }

    // Custom equality: only compare IsAdvanced, not ExpirationDate
    public virtual bool Equals(CustomerStatus? other)
    {
        if (other is null) return false;
        return IsAdvanced == other.IsAdvanced;
    }

    public override int GetHashCode() => IsAdvanced.GetHashCode();
}
```

### Pattern 3: Strongly-Typed ID (record inheriting StronglyTypedId)
**What:** Type-safe wrapper around Guid/int/string with structural equality
**When to use:** All entity IDs (already established pattern)
**Example:**
```csharp
// Source: Current codebase pattern in BuildingBlocks.Common
[DebuggerStepThrough]
public sealed record ProductId(Guid Value) : StronglyTypedId<Guid>(Value)
{
    public static ProductId New() => new(Guid.NewGuid());
    public static ProductId From(Guid value) => new(value);
}

// EF Core conversion
builder.Property(p => p.Id)
    .HasConversion(
        id => id.Value,
        value => new ProductId(value))
    .ValueGeneratedNever();
```

### Anti-Patterns to Avoid
- **ValueObject base class with identity (AddressId):** Address inherits from ValueObject but has identity and mutators - either make it an entity or remove identity
- **Public parameterless constructor:** Structs cannot hide default constructor - bypasses validation. Always use private constructor + static factory
- **Using `with` to bypass validation:** Record `with` creates copies without re-validating invariants - design for immutability or prohibit `with` usage
- **OwnsMany with readonly record struct:** EF Core 10 doesn't support collections of structs - use `record class` or promote to entity

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Equality for value types | Manual `Equals()`, `GetHashCode()`, `==` operators | `readonly record struct` | Compiler generates optimal equality with `EqualityComparer<T>.Default`, 20x faster than reflection-based defaults |
| Immutability enforcement | Custom readonly wrappers, field mutation guards | `readonly record struct` with init-only properties | Language enforces immutability at compile time |
| Deconstruction | Custom Deconstruct method | `record` positional syntax | Compiler generates pattern matching support |
| ToString formatting | Manual string concatenation | `record` auto-generated ToString | Displays all properties automatically |
| Value object base class (new code) | Abstract ValueObject with `GetEqualityComponents()` | `readonly record struct` or `record class` | Records provide same semantics with less boilerplate, unless custom equality needed |

**Key insight:** C# 10+ record structs provide DDD value object semantics (immutability, structural equality) with superior performance and less code. Custom base classes only add value when you need equality component control (e.g., exclude properties, apply rounding).

## Common Pitfalls

### Pitfall 1: Struct Default Constructor Bypasses Validation
**What goes wrong:** Structs always have a parameterless constructor that initializes all fields to default values, bypassing factory method validation.
**Why it happens:** C# language constraint - you cannot delete or make private the default struct constructor.
**How to avoid:** Accept this limitation for simple value objects where default values are acceptable. For critical invariants, use `record class` instead of `readonly record struct`.
**Warning signs:** `Money.Create(100, "USD")` validates, but `new Money()` creates `{Amount: 0, Currency: null}` - invalid state.

### Pitfall 2: EF Core OwnsMany Requires Identity for Collection Items
**What goes wrong:** EF Core cannot map `readonly record struct` to OwnsMany collections because each item needs a primary key.
**Why it happens:** OwnsMany requires unique identity per collection item (composite key: parent FK + item ID).
**How to avoid:** Use `record class` for value objects in collections, or promote to entity if identity is intrinsic. Address is suffering from this - currently uses ValueObject base class with AddressId to satisfy OwnsMany.
**Warning signs:** EF Core migration errors: "owned entity requires a key", or finding AddressId/ItemId in what should be a value object.

### Pitfall 3: `with` Keyword Bypasses Record Validation
**What goes wrong:** Records support non-destructive mutation via `with`, which creates a copy without re-running constructor validation.
**Why it happens:** `with` is syntactic sugar for memberwise copy - it doesn't invoke constructors or factory methods.
**How to avoid:** Design value objects for true immutability (no need for `with`), or accept that `with` is a public API surface. For critical invariants, provide domain methods instead of relying on `with` prevention.
**Warning signs:** `var valid = CustomerStatus.CreateAdvanced(future); var invalid = valid with { ExpirationDate = past };` - invalid state created.

### Pitfall 4: Migration from ValueObject Base Class Requires EF Core Mapping Changes
**What goes wrong:** Changing `Money : ValueObject` to `readonly record struct Money` requires EF Core configuration migration from OwnsOne to ComplexProperty.
**Why it happens:** ValueObject base class uses OwnsOne (owned entity with hidden key), record struct uses ComplexProperty (no key).
**How to avoid:** Migrate incrementally (one value object per migration), test thoroughly, expect database migration changes.
**Warning signs:** Runtime EF Core errors: "type Money is not an owned type", or missing columns after migration.

### Pitfall 5: Record Struct Performance Penalty for Large Value Objects
**What goes wrong:** Large structs (>16 bytes) incur copying overhead when passed by value, negating performance benefits.
**Why it happens:** Structs are value types - every assignment, parameter passing, and return creates a full copy.
**How to avoid:** Use `record class` for value objects with 3+ properties or containing reference types. Use `readonly record struct` only for small, stack-friendly values (ID wrappers, single-value VOs).
**Warning signs:** ShippingAddress (6 string properties) as struct would copy ~50+ bytes on every method call.

## Code Examples

Verified patterns from official sources:

### Migrating ValueObject Base Class to readonly record struct
```csharp
// BEFORE: ValueObject base class (current codebase)
// Source: src/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/Money.cs
public sealed class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }

    private Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    public static Money Create(decimal amount, string currency = "USD")
    {
        Guard.Against.Negative(amount, nameof(amount));
        Guard.Against.NullOrWhiteSpace(currency, nameof(currency));
        return new Money(amount, currency.ToUpperInvariant());
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }

    public override string ToString() => $"{Currency} {Amount:F2}";
}

// EF Core mapping with OwnsOne
builder.OwnsOne(p => p.Price, priceBuilder =>
{
    priceBuilder.Property(m => m.Amount).HasColumnName("Price").HasPrecision(18, 2);
    priceBuilder.Property(m => m.Currency).HasColumnName("Currency").HasMaxLength(3);
});

// AFTER: readonly record struct (recommended)
public readonly record struct Money
{
    public decimal Amount { get; init; }
    public string Currency { get; init; }

    private Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    public static Money Create(decimal amount, string currency = "USD")
    {
        Guard.Against.Negative(amount, nameof(amount));
        Guard.Against.NullOrWhiteSpace(currency, nameof(currency));
        return new Money(amount, currency.ToUpperInvariant());
    }

    public override string ToString() => $"{Currency} {Amount:F2}";
}

// EF Core 8+ mapping with ComplexProperty
builder.ComplexProperty(p => p.Price, money =>
{
    money.Property(m => m.Amount).HasColumnName("Price").HasPrecision(18, 2);
    money.Property(m => m.Currency).HasColumnName("Currency").HasMaxLength(3);
});
```

### Resolving Address Identity Confusion
```csharp
// CURRENT PROBLEM: Address is ValueObject but has identity
// Source: src/MicroCommerce.ApiService/Features/Profiles/Domain/ValueObjects/Address.cs
public sealed class Address : ValueObject  // ← WRONG: has AddressId but inherits ValueObject
{
    public AddressId Id { get; private set; }  // ← Identity = entity, not value object
    public string Street { get; private set; }
    // ...
    internal void SetAsDefault() => IsDefault = true;  // ← Mutators = entity, not VO
}

// SOLUTION 1: Promote to Entity (recommended for OwnsMany collections)
public sealed class Address : BaseEntity<AddressId>
{
    public string Name { get; private set; }
    public string Street { get; private set; }
    public string City { get; private set; }
    public string State { get; private set; }
    public string ZipCode { get; private set; }
    public string Country { get; private set; }
    public bool IsDefault { get; private set; }

    private Address() { }  // EF Core

    private Address(AddressId id, string name, string street, string city,
                   string state, string zipCode, string country)
    {
        Id = id;
        Name = name.Trim();
        Street = street.Trim();
        City = city.Trim();
        State = state.Trim();
        ZipCode = zipCode.Trim();
        Country = country.Trim();
    }

    internal static Address Create(string name, string street, string city,
                                  string state, string zipCode, string country)
    {
        // Validation...
        return new Address(AddressId.New(), name, street, city, state, zipCode, country);
    }

    internal void SetAsDefault() => IsDefault = true;
    internal void ClearDefault() => IsDefault = false;
}

// EF Core OwnsMany remains the same (already supports entities in collections)
builder.OwnsMany(p => p.Addresses, address =>
{
    address.ToTable("Addresses", "profiles");
    address.WithOwner().HasForeignKey("UserProfileId");
    address.HasKey(nameof(Address.Id));
    address.Property(a => a.Id).HasConversion(/* ... */);
    // ...
});

// SOLUTION 2: True Value Object (remove identity, use in single-ownership scenarios)
public readonly record struct Address
{
    public string Street { get; init; }
    public string City { get; init; }
    public string State { get; init; }
    public string ZipCode { get; init; }
    public string Country { get; init; }

    private Address(string street, string city, string state, string zipCode, string country)
    {
        Street = street.Trim();
        City = city.Trim();
        State = state.Trim();
        ZipCode = zipCode.Trim();
        Country = country.Trim();
    }

    public static Address Create(string street, string city, string state,
                                string zipCode, string country)
    {
        // Validation...
        return new Address(street, city, state, zipCode, country);
    }
}

// EF Core ComplexProperty for single address (not collections)
builder.ComplexProperty(p => p.ShippingAddress, address =>
{
    address.Property(a => a.Street).HasMaxLength(200);
    // ...
});
```

### JSON Serialization for record struct Value Objects
```csharp
// Source: Microsoft Learn - System.Text.Json with immutable types
// NO CUSTOM CONVERTER NEEDED - System.Text.Json supports record struct natively

public readonly record struct Money(decimal Amount, string Currency);

// Serialization
var money = new Money(99.99m, "USD");
string json = JsonSerializer.Serialize(money);
// Output: {"Amount":99.99,"Currency":"USD"}

// Deserialization
var deserialized = JsonSerializer.Deserialize<Money>(json);
// Works automatically with positional parameters or init-only properties
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| ValueObject abstract base class | `readonly record struct` or `record class` | C# 9 (records), C# 10 (record struct) | Base class still valid for custom equality; records reduce boilerplate 90% |
| Manual Equals/GetHashCode | Compiler-generated structural equality | C# 9 records | 20x performance improvement for dictionary lookups (verified: nietras.com benchmark) |
| OwnsOne for all value objects | ComplexProperty for structs | EF Core 8 (2023) | No hidden key, cleaner semantics for true value objects |
| Mutable value objects | Immutable by design | C# 9+ records with init | Enforced at compile time, no runtime guards needed |
| Primitive obsession | Strongly-typed IDs and value objects | DDD + modern C# | Already adopted in codebase via StronglyTypedId<T> pattern |

**Deprecated/outdated:**
- **ValueObject base class for new code**: C# 10+ `readonly record struct` provides same semantics with less code. Reserve base class for custom equality scenarios only.
- **OwnsOne for simple value objects**: EF Core 8+ ComplexProperty is cleaner for structs without identity. OwnsOne creates hidden shadow keys unsuitable for true value objects.
- **Implicit conversions on value objects**: ProductName/CategoryName have `implicit operator string` - reduces type safety, prefer explicit `.Value` or `.ToString()`.

## Open Questions

1. **Should Address become an entity or remain a value object without identity?**
   - What we know: Currently inherits ValueObject but has AddressId + mutators; used in OwnsMany collection requiring key
   - What's unclear: Domain modeling intent - is address identity intrinsic (entity) or just EF Core technical requirement?
   - Recommendation: Promote to entity (Solution 1 above) - addresses have lifecycle (add, update, remove, set default), and OwnsMany naturally supports entity collections

2. **What is the migration priority for existing ValueObject-based classes?**
   - What we know: 5 value objects use base class (Money, ProductName, CategoryName, Quantity, DisplayName)
   - What's unclear: Business criticality, performance impact, risk tolerance for EF Core migrations
   - Recommendation: Migrate in order: (1) Address to entity (fixes DDD violation), (2) single-value VOs (ProductName, CategoryName, DisplayName, Quantity), (3) Money (multi-property, requires ComplexProperty testing)

3. **Should we retain ValueObject base class for future custom equality scenarios?**
   - What we know: Zero current value objects use custom equality logic (all use default structural equality)
   - What's unclear: Future domain modeling needs, whether custom equality will emerge
   - Recommendation: Deprecate but retain in BuildingBlocks/Common with documentation: "Use `record class` with equality overrides instead. This base class is maintained for backward compatibility only."

4. **Performance impact of struct vs class for multi-property value objects like ShippingAddress?**
   - What we know: ShippingAddress is already `record class` with 6 string properties; struct would be ~50+ bytes
   - What's unclear: Actual copying overhead in hot paths, GC pressure tradeoffs
   - Recommendation: Benchmark before migrating large value objects to struct. Keep ShippingAddress as `record class` (current state is correct).

## Sources

### Primary (HIGH confidence)
- [Microsoft Learn - Records (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record) - Official C# records documentation
- [Microsoft Learn - Record structs (C# 10 specification)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/record-structs) - Language specification
- [Microsoft Learn - Owned Entity Types (EF Core)](https://learn.microsoft.com/en-us/ef/core/modeling/owned-entities) - EF Core OwnsOne/OwnsMany configuration
- [Microsoft Learn - What's New in EF Core 10](https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-10.0/whatsnew) - Struct and complex type support
- [.NET Blog - EF Core 8 RC1: Complex types as value objects](https://devblogs.microsoft.com/dotnet/announcing-ef8-rc1/) - ComplexProperty feature announcement

### Secondary (MEDIUM confidence)
- [Enterprise Craftsmanship - C# 9 Records as DDD Value Objects](https://enterprisecraftsmanship.com/posts/csharp-records-value-objects/) - Vladimir Khorikov's analysis of records vs ValueObject base class, `with` keyword concerns
- [Enterprise Craftsmanship - .NET Value Type (struct) as a DDD Value Object](https://enterprisecraftsmanship.com/posts/net-value-type-ddd-value-object/) - Struct limitations: encapsulation, default constructor, ORM support
- [Milan Jovanovic - Value Objects in .NET (DDD Fundamentals)](https://www.milanjovanovic.tech/blog/value-objects-in-dotnet-ddd-fundamentals) - Implementation comparison, EF Core 8+ ComplexProperty guidance
- [nietras.com - C# 10 record struct Deep Dive & Performance Implications](https://nietras.com/2021/06/14/csharp-10-record-struct/) - 20x performance benchmark for dictionary operations
- [Microsoft Learn - System.Text.Json immutable types](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/immutability) - JSON serialization for records

### Tertiary (LOW confidence - marked for validation)
- GitHub discussions on eShopOnContainers ValueObject vs records (community opinions, not official Microsoft guidance)
- Medium articles on record struct best practices (2025-2026) - useful but not authoritative

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - C# 13, EF Core 10 features verified with official Microsoft documentation
- Architecture: HIGH - Patterns validated against Enterprise Craftsmanship (Khorikov) and Microsoft official guidance
- Pitfalls: MEDIUM-HIGH - Default constructor and OwnsMany limitations verified, `with` bypass documented by Khorikov, migration risks based on EF Core docs
- Performance: MEDIUM - 20x benchmark from nietras.com (reputable source), but project-specific profiling needed
- Address resolution: HIGH - DDD entity/value-object distinction is well-established, OwnsMany requiring key is documented EF Core behavior

**Research date:** 2026-02-14
**Valid until:** 60 days (stable domain - C# 13 and EF Core 10 are established, DDD patterns are timeless)

**Current codebase inventory:**
- **ValueObject base class users (5):** Money, ProductName, CategoryName, Quantity, DisplayName
- **record class value objects (3):** Rating, ReviewText, ShippingAddress
- **record strongly-typed IDs (13):** All *Id classes inherit from StronglyTypedId<T> base record
- **Critical DDD issue (1):** Address inherits ValueObject but has AddressId + mutators (entity masquerading as value object)
