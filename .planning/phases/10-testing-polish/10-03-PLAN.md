---
phase: 10-testing-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/MicroCommerce.ApiService.Tests/Unit/Ordering/Sagas/CheckoutStateMachineTests.cs
autonomous: true

must_haves:
  truths:
    - "CheckoutStarted event transitions saga to Submitted state and publishes ReserveStockForOrder"
    - "StockReservationCompleted in Submitted state transitions to StockReserved and stores ReservationIdsJson"
    - "StockReservationFailed in Submitted state transitions to Failed, publishes OrderFailed, and finalizes saga"
    - "PaymentCompleted in StockReserved state transitions to Confirmed, publishes ConfirmOrder + DeductStock + ClearCart, and finalizes"
    - "PaymentFailed in StockReserved state publishes ReleaseStockReservations + OrderFailed, transitions to Failed, and finalizes"
    - "Saga correlation works via OrderId across all events"
  artifacts:
    - path: "src/MicroCommerce.ApiService.Tests/Unit/Ordering/Sagas/CheckoutStateMachineTests.cs"
      provides: "Comprehensive saga state machine tests for happy path and all failure/compensation paths"
  key_links:
    - from: "CheckoutStateMachineTests.cs"
      to: "CheckoutStateMachine"
      via: "MassTransit SagaTestHarness"
      pattern: "AddSagaStateMachine<CheckoutStateMachine"
---

<objective>
Write comprehensive tests for the CheckoutStateMachine using MassTransit's SagaTestHarness. This covers the most complex orchestration logic in the system - the checkout flow with stock reservation, payment, confirmation, and compensation on failure.

Purpose: The checkout saga is the highest-risk component (orchestrates multiple services). Testing it verifies state transitions, message publishing, and compensation logic without requiring real infrastructure.
Output: Saga test file with tests for all happy paths and failure/compensation scenarios.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/MicroCommerce.ApiService/Features/Ordering/Application/Saga/CheckoutStateMachine.cs
@src/MicroCommerce.ApiService/Features/Ordering/Application/Saga/CheckoutState.cs
@src/MicroCommerce.ApiService/Features/Ordering/Application/Saga/Contracts.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write CheckoutStateMachine saga tests with SagaTestHarness</name>
  <files>
    src/MicroCommerce.ApiService.Tests/Unit/Ordering/Sagas/CheckoutStateMachineTests.cs
  </files>
  <action>
    NOTE: This plan runs in parallel with Plan 01 (wave 1). If the test project doesn't exist yet, create it first using the same steps as Plan 01 Task 1.

    Create comprehensive saga state machine tests using MassTransit's `AddMassTransitTestHarness` pattern:

    **Test setup pattern:**
    Each test creates its own `ServiceCollection`, adds `MassTransitTestHarness` with `CheckoutStateMachine` and `InMemoryRepository`, builds provider, starts harness. Use a helper method or setup pattern to reduce duplication. Remember: `await harness.Start()` MUST be called before publishing.

    ```csharp
    await using var provider = new ServiceCollection()
        .AddMassTransitTestHarness(cfg =>
        {
            cfg.AddSagaStateMachine<CheckoutStateMachine, CheckoutState>()
                .InMemoryRepository();
        })
        .BuildServiceProvider(true);

    var harness = provider.GetRequiredService<ITestHarness>();
    await harness.Start();
    var sagaHarness = harness.GetSagaStateMachineHarness<CheckoutStateMachine, CheckoutState>();
    ```

    **Happy path tests:**
    - `CheckoutStarted_TransitionsToSubmitted_PublishesReserveStock` - Start saga, verify it enters Submitted state and publishes `ReserveStockForOrder`
    - `StockReservationCompleted_InSubmitted_TransitionsToStockReserved` - Publish `CheckoutStarted` then `StockReservationCompleted`, verify StockReserved state and ReservationIdsJson stored
    - `PaymentCompleted_InStockReserved_TransitionsToConfirmed_PublishesAll` - Full happy path: CheckoutStarted -> StockReservationCompleted -> PaymentCompleted. Verify Confirmed state. Verify `ConfirmOrder`, `DeductStock`, and `ClearCart` messages published. Verify saga finalized (SetCompletedWhenFinalized removes it).

    **Failure path tests (stock reservation failed):**
    - `StockReservationFailed_InSubmitted_TransitionsToFailed_PublishesOrderFailed` - Publish `CheckoutStarted` then `StockReservationFailed`. Verify Failed state, `OrderFailed` message published with reason, saga finalized.

    **Failure path tests (payment failed - compensation):**
    - `PaymentFailed_InStockReserved_TransitionsToFailed_CompensatesStock` - Full compensation path: CheckoutStarted -> StockReservationCompleted -> PaymentFailed. Verify:
      1. `ReleaseStockReservations` published (compensation)
      2. `OrderFailed` published with reason
      3. Saga transitions to Failed
      4. Saga finalized
      5. FailureReason set on saga state

    **State data verification tests:**
    - `CheckoutStarted_StoresSagaData` - Verify OrderId, BuyerId, BuyerEmail, SubmittedAt set on saga state
    - `StockReservationCompleted_StoresReservationIds` - Verify ReservationIdsJson saved

    **Correlation tests:**
    - `MultipleOrders_IndependentSagaInstances` - Publish CheckoutStarted for two different OrderIds, verify two separate saga instances created in correct states

    Use `[Trait("Category", "Unit")]` on the test class. Use FluentAssertions.
    Check published messages with: `(await harness.Published.Any<MessageType>()).Should().BeTrue()`
    Check saga state with: `(await sagaHarness.Exists(correlationId, x => x.StateName)).Should().NotBeNull()`
    For finalized sagas, verify with `sagaHarness.Exists(correlationId, x => x.Final)` or check Created/Sagas counts.

    IMPORTANT: Use `await Task.Delay(100)` or `harness.Published.Any<T>(timeout: TimeSpan.FromSeconds(5))` with appropriate timeout to allow async message processing before assertions.

    Helper method to create a standard `CheckoutStarted` message with test data (orderId, buyerId, email, 1 item).
  </action>
  <verify>
    `dotnet test src/MicroCommerce.ApiService.Tests/ --filter "Category=Unit&FullyQualifiedName~Sagas" --verbosity normal` - All saga tests pass.
    At least 9 test methods covering: happy path (3), stock failure (1), payment failure compensation (1), state data (2), correlation (1), plus any additional edge cases.
  </verify>
  <done>
    CheckoutStateMachine fully tested: happy path through Submitted -> StockReserved -> Confirmed with all published messages verified. Stock reservation failure path tested. Payment failure compensation path tested (ReleaseStockReservations + OrderFailed). Saga state data (OrderId, BuyerId, ReservationIdsJson) verified. Independent saga correlation for multiple orders verified.
  </done>
</task>

</tasks>

<verification>
1. `dotnet test src/MicroCommerce.ApiService.Tests/ --filter "FullyQualifiedName~Sagas"` - All saga tests pass
2. Happy path: CheckoutStarted -> StockReservationCompleted -> PaymentCompleted -> Confirmed + finalized
3. Stock failure: CheckoutStarted -> StockReservationFailed -> Failed + finalized
4. Payment failure + compensation: CheckoutStarted -> StockReservationCompleted -> PaymentFailed -> ReleaseStockReservations published + Failed + finalized
5. No real database, message bus, or external services used (InMemory only)
</verification>

<success_criteria>
- 9+ saga tests covering all state machine paths
- Happy path (reserve -> pay -> confirm) verified with all published messages
- Both failure paths (stock failed, payment failed) verified
- Compensation (ReleaseStockReservations) verified on payment failure
- Saga finalization (SetCompletedWhenFinalized) verified
- Tests are fast (<5 seconds total) using InMemory harness
</success_criteria>

<output>
After completion, create `.planning/phases/10-testing-polish/10-03-SUMMARY.md`
</output>
