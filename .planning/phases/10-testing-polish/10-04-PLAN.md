---
phase: 10-testing-polish
plan: 04
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/MicroCommerce.ApiService.Tests/Integration/Fixtures/ApiWebApplicationFactory.cs
  - src/MicroCommerce.ApiService.Tests/Integration/Fixtures/IntegrationTestCollection.cs
  - src/MicroCommerce.ApiService.Tests/Integration/Catalog/CatalogEndpointsTests.cs
  - src/MicroCommerce.ApiService.Tests/Integration/Cart/CartEndpointsTests.cs
  - src/MicroCommerce.ApiService.Tests/Integration/Inventory/InventoryEndpointsTests.cs
  - src/MicroCommerce.ApiService.Tests/Integration/Ordering/OrderingEndpointsTests.cs
autonomous: true

must_haves:
  truths:
    - "Integration tests run against a real PostgreSQL database via Testcontainers"
    - "GET /api/catalog/products returns 200 with product list"
    - "POST /api/catalog/products creates a product and returns 201"
    - "Cart endpoints (add, get, update, remove) work end-to-end with cookie-based buyer identity"
    - "POST /api/ordering/checkout creates an order and returns 201 with OrderId and OrderNumber"
    - "GET /api/ordering/orders/{id} returns order details"
    - "Inventory endpoints (adjust stock, get stock) work with real database"
    - "Integration tests run without requiring external Service Bus infrastructure"
    - "Database migrations applied automatically in test setup"
  artifacts:
    - path: "src/MicroCommerce.ApiService.Tests/Integration/Fixtures/ApiWebApplicationFactory.cs"
      provides: "Custom WebApplicationFactory with Testcontainers PostgreSQL and MassTransit test harness"
    - path: "src/MicroCommerce.ApiService.Tests/Integration/Fixtures/IntegrationTestCollection.cs"
      provides: "xUnit collection fixture for sharing WAF across test classes"
    - path: "src/MicroCommerce.ApiService.Tests/Integration/Catalog/CatalogEndpointsTests.cs"
      provides: "Integration tests for all catalog API endpoints"
    - path: "src/MicroCommerce.ApiService.Tests/Integration/Ordering/OrderingEndpointsTests.cs"
      provides: "Integration tests for ordering/checkout API endpoints"
  key_links:
    - from: "ApiWebApplicationFactory"
      to: "Testcontainers PostgreSQL"
      via: "PostgreSqlContainer replacing all DbContext connection strings"
      pattern: "_dbContainer\\.GetConnectionString"
    - from: "ApiWebApplicationFactory"
      to: "MassTransit"
      via: "AddMassTransitTestHarness replacing real Service Bus"
      pattern: "AddMassTransitTestHarness"
---

<objective>
Create integration test infrastructure (WebApplicationFactory with Testcontainers) and write API endpoint integration tests for all four feature modules. These tests hit real HTTP endpoints with a real PostgreSQL database, verifying the full request pipeline including routing, validation, MediatR dispatch, and database persistence.

Purpose: Integration tests verify that all layers work together - routing, validation, handlers, EF Core, and database. Testcontainers ensures tests match production PostgreSQL behavior.
Output: Shared test fixture (ApiWebApplicationFactory) and integration test files for Catalog, Cart, Inventory, and Ordering endpoints.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-testing-polish/10-01-SUMMARY.md

@src/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
@src/MicroCommerce.ApiService/Features/Cart/CartEndpoints.cs
@src/MicroCommerce.ApiService/Features/Inventory/InventoryEndpoints.cs
@src/MicroCommerce.ApiService/Features/Ordering/OrderingEndpoints.cs
@src/MicroCommerce.ApiService/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApiWebApplicationFactory with Testcontainers and collection fixture</name>
  <files>
    src/MicroCommerce.ApiService.Tests/Integration/Fixtures/ApiWebApplicationFactory.cs
    src/MicroCommerce.ApiService.Tests/Integration/Fixtures/IntegrationTestCollection.cs
  </files>
  <action>
    **ApiWebApplicationFactory.cs:**
    Create a custom `WebApplicationFactory<Program>` that implements `IAsyncLifetime`:

    1. Create a `PostgreSqlContainer` using `PostgreSqlBuilder` with `postgres:15-alpine` image and `microcommerce_test` database name.
    2. In `ConfigureWebHost`, override services to:
       a. Replace ALL DbContext connection strings with the Testcontainer connection string. The project has 4 DbContexts: `CatalogDbContext`, `InventoryDbContext`, `CartDbContext`, `OrderingDbContext`. For each, remove existing `DbContextOptions<T>` and re-register with `UseNpgsql(_dbContainer.GetConnectionString())`.
       b. Replace MassTransit with `AddMassTransitTestHarness()` to avoid real Service Bus dependency.
       c. Replace cloud-dependent services that would fail without real infrastructure:
          - Azure Blob Storage: Remove `BlobServiceClient` registration and replace with a no-op or in-memory stub if image upload endpoints are tested.
          - Keycloak/JWT Authentication: Configure test authentication using `AddAuthentication("Test").AddScheme<TestAuthHandler>("Test", ...)` or bypass auth entirely with `builder.ConfigureTestServices(s => s.AddAuthorization(o => o.AddPolicy(...)))`.
          - Data Seeders: Remove or disable `BackgroundService` data seeder registrations (`CatalogDataSeeder`, `InventoryDataSeeder`, etc.) to prevent seed data interfering with test isolation.
       d. Optionally disable data seeders (BackgroundService classes) to prevent seed data interfering with test isolation. Remove or configure `HostedService` registrations for data seeders.
    3. In `InitializeAsync()`:
       a. Start the Testcontainer: `await _dbContainer.StartAsync()`
       b. After creating a scope from `Services`, apply migrations for ALL DbContexts:
          ```csharp
          using var scope = Services.CreateScope();
          var catalog = scope.ServiceProvider.GetRequiredService<CatalogDbContext>();
          await catalog.Database.MigrateAsync();
          // Same for Inventory, Cart, Ordering DbContexts
          ```
    4. In `DisposeAsync()`: Dispose the container.

    IMPORTANT: The Program class must be accessible. If `Program` is not public, add `[assembly: InternalsVisibleTo("MicroCommerce.ApiService.Tests")]` or use a partial class approach. Check if there's already a way to access Program - likely need `public partial class Program { }` at the bottom of Program.cs or a marker attribute.

    IMPORTANT: Handle the Aspire service discovery URLs. The DbContexts may be configured via Aspire connection strings (e.g., `builder.AddNpgsqlDbContext<CatalogDbContext>("catalogdb")`). In tests, you need to replace these with direct Testcontainer connection strings.

    **IntegrationTestCollection.cs:**
    Define the xUnit collection fixture:
    ```csharp
    [CollectionDefinition("Integration Tests")]
    public class IntegrationTestCollection : ICollectionFixture<ApiWebApplicationFactory> { }
    ```
    This ensures one PostgreSQL container is shared across all integration test classes.
  </action>
  <verify>
    A simple test class using the factory should compile. Build the test project: `dotnet build src/MicroCommerce.ApiService.Tests/`
  </verify>
  <done>
    ApiWebApplicationFactory starts a Testcontainers PostgreSQL instance, replaces all 4 DbContext connection strings, replaces MassTransit with InMemoryTestHarness, applies all EF migrations, and provides HttpClient for integration tests. Collection fixture enables shared container across test classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for all API endpoints</name>
  <files>
    src/MicroCommerce.ApiService.Tests/Integration/Catalog/CatalogEndpointsTests.cs
    src/MicroCommerce.ApiService.Tests/Integration/Cart/CartEndpointsTests.cs
    src/MicroCommerce.ApiService.Tests/Integration/Inventory/InventoryEndpointsTests.cs
    src/MicroCommerce.ApiService.Tests/Integration/Ordering/OrderingEndpointsTests.cs
  </files>
  <action>
    All test classes use `[Collection("Integration Tests")]` and `IClassFixture<ApiWebApplicationFactory>`. Use `[Trait("Category", "Integration")]`.

    **CatalogEndpointsTests.cs:**
    - `GetProducts_EmptyDatabase_ReturnsEmptyList` - GET /api/catalog/products
    - `CreateProduct_ValidRequest_Returns201` - POST /api/catalog/products (create category first, then product)
    - `CreateProduct_InvalidRequest_Returns400` - Missing required fields
    - `GetProductById_ExistingProduct_ReturnsProduct` - Create then GET /api/catalog/products/{id}
    - `GetProductById_NonExistent_Returns404` - Random GUID
    - `UpdateProduct_ValidRequest_ReturnsUpdated` - PUT /api/catalog/products/{id}
    - `GetCategories_ReturnsCategories` - GET /api/catalog/categories
    - `CreateCategory_ValidRequest_Returns201` - POST /api/catalog/categories

    NOTE: Before tests that create products, first create a category via POST /api/catalog/categories and use its ID. Each test should be self-contained.

    **CartEndpointsTests.cs:**
    - `AddToCart_ValidItem_Returns200` - POST /api/cart/items (include buyer identity cookie)
    - `GetCart_EmptyCart_ReturnsEmptyItems` - GET /api/cart
    - `GetCart_AfterAddItem_ReturnsItemInCart` - Add then GET
    - `UpdateCartItem_ValidQuantity_Updates` - PUT /api/cart/items/{itemId}
    - `RemoveCartItem_ExistingItem_Removes` - DELETE /api/cart/items/{itemId}

    NOTE: Cart uses cookie-based buyer identity. The test HttpClient must include a `buyer_id` cookie with a GUID value. Create a helper to get/set this cookie, or use `HttpRequestMessage` with cookie header.

    **InventoryEndpointsTests.cs:**
    - `GetStockLevels_ExistingProductIds_ReturnsStockInfo` - POST /api/inventory/stock/batch
    - `AdjustStock_ValidAdjustment_UpdatesQuantity` - POST /api/inventory/stock/adjust (need to create stock item first or use seeded data)

    NOTE: StockItems are usually created by the `ProductCreatedDomainEvent` consumer. Since MassTransit is replaced with test harness, you may need to seed stock data directly in the test or trigger the consumer manually.

    **OrderingEndpointsTests.cs:**
    - `Checkout_ValidRequest_Returns201WithOrderId` - POST /api/ordering/checkout with email, address, items
    - `Checkout_InvalidRequest_Returns400` - Missing email/address
    - `GetOrderById_ExistingOrder_ReturnsOrder` - Create order then GET
    - `GetOrderById_NonExistent_Returns404` - Random GUID
    - `GetMyOrders_WithBuyerId_ReturnsOrders` - GET /api/ordering/orders/my
    - `GetAllOrders_ReturnsOrderList` - GET /api/ordering/orders
    - `GetDashboard_ReturnsDashboardStats` - GET /api/ordering/dashboard

    NOTE: For ordering tests, you need to be pragmatic. The checkout publishes `CheckoutStarted` to initiate the saga, but with InMemoryTestHarness, the saga consumers won't run against real DB. Focus on testing the HTTP contract and SubmitOrderCommandHandler directly. The order should be created in Submitted status.

    Use `factory.CreateClient()` for each test class constructor. Use `HttpClient.PostAsJsonAsync`, `GetFromJsonAsync`, `ReadFromJsonAsync` for request/response serialization. Use FluentAssertions for status code and response body assertions.

    Each test file should have a clear Arrange/Act/Assert structure. Use descriptive test names following `Method_Scenario_Expected` convention.
  </action>
  <verify>
    `dotnet test src/MicroCommerce.ApiService.Tests/ --filter "Category=Integration" --verbosity normal` - All integration tests pass.
    Tests require Docker running (Testcontainers). At least 20 integration tests across 4 files.
  </verify>
  <done>
    Integration tests verify all API endpoint contracts against real PostgreSQL. Catalog CRUD, Cart item management, Inventory stock queries, and Ordering checkout/query endpoints all have passing tests. Tests are isolated via collection fixture and run with Testcontainers.
  </done>
</task>

</tasks>

<verification>
1. Docker must be running for Testcontainers
2. `dotnet test src/MicroCommerce.ApiService.Tests/ --filter "Category=Integration"` - All pass
3. At least 20 integration tests covering all 4 feature modules
4. No tests depend on external services (Keycloak, Azure Blob, Azure Service Bus)
5. Database migrations applied automatically (no manual schema setup)
6. Tests can run in parallel within the same collection (no shared mutable DB state between tests that would conflict)
</verification>

<success_criteria>
- ApiWebApplicationFactory created with Testcontainers PostgreSQL replacing all 4 DbContexts
- MassTransit replaced with InMemoryTestHarness
- Integration tests cover: Catalog (8+), Cart (5+), Inventory (2+), Ordering (7+)
- All tests pass with `dotnet test`
- Tests demonstrate the full HTTP request pipeline: routing -> validation -> handler -> DB -> response
</success_criteria>

<output>
After completion, create `.planning/phases/10-testing-polish/10-04-SUMMARY.md`
</output>
