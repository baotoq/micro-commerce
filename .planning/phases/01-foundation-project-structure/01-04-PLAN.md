---
phase: 01-foundation-project-structure
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - code/MicroCommerce.ApiService/Common/Persistence/DomainEventInterceptor.cs
  - code/MicroCommerce.ApiService/Common/Persistence/OutboxDbContext.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/CatalogDbContext.cs
  - code/MicroCommerce.ApiService/Features/Cart/Infrastructure/CartDbContext.cs
  - code/MicroCommerce.ApiService/Features/Ordering/Infrastructure/OrderingDbContext.cs
  - code/MicroCommerce.ApiService/Features/Inventory/Infrastructure/InventoryDbContext.cs
  - code/MicroCommerce.ApiService/Program.cs
  - code/BuildingBlocks/BuildingBlocks.Common/Events/MediatorDomainEventDispatcher.cs
  - code/BuildingBlocks/BuildingBlocks.Common/Events/IDomainEventDispatcher.cs
  - code/BuildingBlocks/BuildingBlocks.Common/Events/IDomainEventHandler.cs
autonomous: true

must_haves:
  truths:
    - "Domain events raised by aggregates are published to Service Bus via transactional outbox"
    - "Events are saved to outbox within same transaction as aggregate changes"
    - "MassTransit delivery service publishes outbox messages to Azure Service Bus"
    - "Old MediatorDomainEventDispatcher is removed/deprecated"
  artifacts:
    - path: "code/MicroCommerce.ApiService/Common/Persistence/DomainEventInterceptor.cs"
      provides: "EF Core interceptor that publishes domain events after SaveChanges"
      contains: "SaveChangesInterceptor"
    - path: "code/MicroCommerce.ApiService/Common/Persistence/OutboxDbContext.cs"
      provides: "Shared DbContext for MassTransit outbox tables"
      contains: "AddOutboxMessageEntity"
    - path: "code/MicroCommerce.ApiService/Program.cs"
      provides: "MassTransit configuration with Azure Service Bus and EF Core outbox"
      contains: "AddMassTransit"
  key_links:
    - from: "code/MicroCommerce.ApiService/Common/Persistence/DomainEventInterceptor.cs"
      to: "MassTransit IPublishEndpoint"
      via: "Constructor injection"
      pattern: "IPublishEndpoint"
    - from: "code/MicroCommerce.ApiService/Program.cs"
      to: "Azure Service Bus transport"
      via: "MassTransit UsingAzureServiceBus"
      pattern: "UsingAzureServiceBus"
---

<objective>
Implement transactional outbox pattern for domain events using MassTransit with Azure Service Bus transport.

Purpose: Ensure domain events are reliably published with at-least-once delivery, even if the application crashes after database commit.
Output: DomainEventInterceptor, OutboxDbContext, MassTransit configuration, deprecation of old dispatcher.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-project-structure/01-CONTEXT.md
@.planning/phases/01-foundation-project-structure/01-RESEARCH.md
@code/BuildingBlocks/BuildingBlocks.Common/BaseAggregateRoot.cs
@code/BuildingBlocks/BuildingBlocks.Common/Events/DomainEvent.cs
@code/BuildingBlocks/BuildingBlocks.Common/Events/MediatorDomainEventDispatcher.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OutboxDbContext and DomainEventInterceptor</name>
  <files>
code/MicroCommerce.ApiService/Common/Persistence/OutboxDbContext.cs
code/MicroCommerce.ApiService/Common/Persistence/DomainEventInterceptor.cs
  </files>
  <action>
Create Common/Persistence/ folder with outbox infrastructure:

**OutboxDbContext.cs:**
```csharp
using MassTransit;
using Microsoft.EntityFrameworkCore;

namespace MicroCommerce.ApiService.Common.Persistence;

/// <summary>
/// Shared DbContext for MassTransit transactional outbox.
/// All modules share this outbox for domain event publishing.
/// </summary>
public class OutboxDbContext : DbContext
{
    public OutboxDbContext(DbContextOptions<OutboxDbContext> options)
        : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Outbox tables in 'outbox' schema
        modelBuilder.HasDefaultSchema("outbox");

        // MassTransit outbox entities for transactional messaging
        modelBuilder.AddInboxStateEntity();
        modelBuilder.AddOutboxMessageEntity();
        modelBuilder.AddOutboxStateEntity();
    }
}
```

**DomainEventInterceptor.cs:**
```csharp
using MassTransit;
using MicroCommerce.BuildingBlocks.Common;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;

namespace MicroCommerce.ApiService.Common.Persistence;

/// <summary>
/// EF Core interceptor that publishes domain events after SaveChanges completes.
/// Events are written to the MassTransit outbox within the same transaction.
/// </summary>
public class DomainEventInterceptor : SaveChangesInterceptor
{
    private readonly IPublishEndpoint _publishEndpoint;

    public DomainEventInterceptor(IPublishEndpoint publishEndpoint)
    {
        _publishEndpoint = publishEndpoint;
    }

    public override async ValueTask<int> SavedChangesAsync(
        SaveChangesCompletedEventData eventData,
        int result,
        CancellationToken cancellationToken = default)
    {
        await DispatchDomainEventsAsync(eventData.Context, cancellationToken);
        return result;
    }

    public override int SavedChanges(
        SaveChangesCompletedEventData eventData,
        int result)
    {
        // Sync version - dispatch async but don't await (fire and forget for sync path)
        // In practice, always use SaveChangesAsync for domain events
        DispatchDomainEventsAsync(eventData.Context, CancellationToken.None)
            .ConfigureAwait(false)
            .GetAwaiter()
            .GetResult();
        return result;
    }

    private async Task DispatchDomainEventsAsync(DbContext? context, CancellationToken cancellationToken)
    {
        if (context is null)
            return;

        // Find all aggregates with domain events
        var aggregates = context.ChangeTracker
            .Entries<IAggregateRoot>()
            .Where(e => e.Entity.DomainEvents.Any())
            .Select(e => e.Entity)
            .ToList();

        // Collect all events
        var domainEvents = aggregates
            .SelectMany(a => a.DomainEvents)
            .ToList();

        // Clear events from aggregates (prevent re-publishing)
        foreach (var aggregate in aggregates)
        {
            aggregate.ClearDomainEvents();
        }

        // Publish to outbox (MassTransit handles transactional write to outbox table)
        foreach (var domainEvent in domainEvents)
        {
            await _publishEndpoint.Publish(
                domainEvent,
                domainEvent.GetType(),
                cancellationToken);
        }
    }
}
```

Key design decisions:
- Shared OutboxDbContext for all modules (simpler outbox management)
- Interceptor runs AFTER SaveChanges succeeds (events match committed data)
- Events are thin (IDs only) per CONTEXT.md
- MassTransit outbox handles actual Service Bus publishing
  </action>
  <verify>
Run `dotnet build code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` - should compile.
  </verify>
  <done>
OutboxDbContext has MassTransit outbox tables, DomainEventInterceptor publishes events via outbox.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure MassTransit with Azure Service Bus and outbox</name>
  <files>code/MicroCommerce.ApiService/Program.cs</files>
  <action>
Update Program.cs to configure MassTransit with Azure Service Bus transport and EF Core outbox.

Add using statements:
```csharp
using MassTransit;
using MicroCommerce.ApiService.Common.Persistence;
using Microsoft.EntityFrameworkCore;
```

Add DbContext and MassTransit registration BEFORE MediatR registration:

```csharp
// Outbox DbContext for transactional domain events
builder.AddNpgsqlDbContext<OutboxDbContext>("appdb", configureDbContextOptions: options =>
{
    options.UseNpgsql(npgsql =>
        npgsql.MigrationsHistoryTable("__EFMigrationsHistory", "outbox"));
});

// Module DbContexts with interceptor for domain events
builder.AddNpgsqlDbContext<CatalogDbContext>("appdb", configureDbContextOptions: options =>
{
    options.UseNpgsql(npgsql =>
        npgsql.MigrationsHistoryTable("__EFMigrationsHistory", "catalog"));
    options.AddInterceptors(builder.Services.BuildServiceProvider().GetRequiredService<DomainEventInterceptor>());
});

// Add similar for CartDbContext, OrderingDbContext, InventoryDbContext...

// MassTransit with Azure Service Bus and EF Core outbox
builder.Services.AddMassTransit(x =>
{
    // Auto-discover consumers from assembly
    x.AddConsumers(typeof(Program).Assembly);

    // EF Core outbox for transactional messaging
    x.AddEntityFrameworkOutbox<OutboxDbContext>(o =>
    {
        o.UsePostgres();
        o.UseBusOutbox();  // Enable delivery service
        o.QueryDelay = TimeSpan.FromSeconds(1);  // Poll interval for outbox
    });

    x.UsingAzureServiceBus((context, cfg) =>
    {
        cfg.Host(builder.Configuration.GetConnectionString("messaging"));
        cfg.ConfigureEndpoints(context);
    });
});

// Register interceptor for DI
builder.Services.AddScoped<DomainEventInterceptor>();
```

**Note:** The Aspire builder.AddNpgsqlDbContext extension handles connection string injection from AppHost references.
  </action>
  <verify>
Run `dotnet build code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` - should compile.
Verify Program.cs contains "AddMassTransit", "UsingAzureServiceBus", "AddEntityFrameworkOutbox".
  </verify>
  <done>
MassTransit configured with Azure Service Bus transport and EF Core outbox for reliable domain events.
  </done>
</task>

<task type="auto">
  <name>Task 3: Deprecate old MediatorDomainEventDispatcher</name>
  <files>
code/BuildingBlocks/BuildingBlocks.Common/Events/MediatorDomainEventDispatcher.cs
code/BuildingBlocks/BuildingBlocks.Common/Events/IDomainEventDispatcher.cs
code/BuildingBlocks/BuildingBlocks.Common/Events/IDomainEventHandler.cs
  </files>
  <action>
Mark the old in-process domain event infrastructure as obsolete. Don't delete yet (may be useful for unit testing), but clearly indicate it's replaced.

**Update MediatorDomainEventDispatcher.cs:**
Add [Obsolete] attribute with migration guidance:
```csharp
using MediatR;

namespace MicroCommerce.BuildingBlocks.Common.Events;

/// <summary>
/// DEPRECATED: Use MassTransit with transactional outbox instead.
/// Domain events should be published via IPublishEndpoint for reliable delivery.
/// This class remains for backward compatibility and unit testing scenarios.
/// </summary>
[Obsolete("Use MassTransit IPublishEndpoint with transactional outbox. See DomainEventInterceptor in ApiService.")]
public class MediatorDomainEventDispatcher(IMediator mediator) : IDomainEventDispatcher
{
    public Task DispatchAsync<T>(IEnumerable<T> domainEvents) where T : IDomainEvent
    {
        return Task.WhenAll(domainEvents.Select(e => mediator.Publish(e)));
    }

    public Task DispatchAsync<T>(IDomainEvent domainEvent) where T : IDomainEvent
    {
        return mediator.Publish(domainEvent);
    }
}
```

**Update IDomainEventDispatcher.cs:**
Add obsolete attribute:
```csharp
namespace MicroCommerce.BuildingBlocks.Common.Events;

[Obsolete("Use MassTransit IPublishEndpoint with transactional outbox. See DomainEventInterceptor in ApiService.")]
public interface IDomainEventDispatcher
{
    Task DispatchAsync<T>(IEnumerable<T> domainEvents) where T : IDomainEvent;
    Task DispatchAsync<T>(IDomainEvent domainEvent) where T : IDomainEvent;
}
```

**Update IDomainEventHandler.cs:**
Add obsolete attribute:
```csharp
namespace MicroCommerce.BuildingBlocks.Common.Events;

[Obsolete("Use MassTransit IConsumer<T> for domain event handling. Events are published via Service Bus.")]
public interface IDomainEventHandler<in T> : MediatR.INotificationHandler<T>
    where T : IDomainEvent
{
}
```

This approach:
- Preserves the old code for reference/testing
- Compiler warnings guide developers to new pattern
- Clear migration path in obsolete messages
  </action>
  <verify>
Run `dotnet build code/BuildingBlocks/BuildingBlocks.Common/BuildingBlocks.Common.csproj` - should compile with warnings about obsolete usage.
  </verify>
  <done>
Old MediatorDomainEventDispatcher marked obsolete with clear migration guidance to MassTransit outbox.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build code/MicroCommerce.sln` compiles (may have obsolete warnings, that's expected)
2. OutboxDbContext.cs contains MassTransit outbox entity registration
3. DomainEventInterceptor.cs publishes via IPublishEndpoint
4. Program.cs configures MassTransit with Azure Service Bus
5. Old dispatcher files have [Obsolete] attributes
</verification>

<success_criteria>
- Domain events from aggregates are captured by DomainEventInterceptor
- Events are written to outbox table within same transaction as aggregate changes
- MassTransit delivery service publishes outbox messages to Azure Service Bus
- Old MediatorDomainEventDispatcher is marked obsolete with migration guidance
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-project-structure/01-04-SUMMARY.md`
</output>
