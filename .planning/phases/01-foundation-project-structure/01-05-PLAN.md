---
phase: 01-foundation-project-structure
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommand.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandHandler.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandValidator.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategories/GetCategoriesQuery.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategories/GetCategoriesQueryHandler.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategories/CategoryDto.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Category.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/CategoryId.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/CategoryName.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/Events/CategoryCreatedDomainEvent.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/CatalogDbContext.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/CategoryConfiguration.cs
  - code/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
  - .planning/phases/01-foundation-project-structure/CQRS-GUIDELINES.md
autonomous: true

must_haves:
  truths:
    - "POST /api/catalog/categories creates a category via CreateCategoryCommand"
    - "GET /api/catalog/categories returns categories via GetCategoriesQuery"
    - "CreateCategoryCommand validation fails fast with structured errors"
    - "Category aggregate raises CategoryCreatedDomainEvent"
    - "Developers can copy this structure as template for new features"
  artifacts:
    - path: "code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommand.cs"
      provides: "Command record with IRequest<CategoryId>"
      contains: "IRequest<CategoryId>"
    - path: "code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandHandler.cs"
      provides: "Handler that creates Category aggregate"
      contains: "IRequestHandler"
    - path: "code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandValidator.cs"
      provides: "FluentValidation validator"
      contains: "AbstractValidator"
    - path: "code/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Category.cs"
      provides: "Category aggregate with domain events"
      contains: "BaseAggregateRoot"
    - path: ".planning/phases/01-foundation-project-structure/CQRS-GUIDELINES.md"
      provides: "CQRS usage guidelines for developers"
      contains: "Command"
  key_links:
    - from: "code/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs"
      to: "MediatR ISender"
      via: "Endpoint sends command/query"
      pattern: "sender\\.Send"
    - from: "code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandHandler.cs"
      to: "CatalogDbContext"
      via: "Repository access"
      pattern: "CatalogDbContext"
---

<objective>
Create a complete reference implementation of the CQRS pattern with Category entity, demonstrating command, query, validation, domain events, and minimal API endpoints.

Purpose: Provide a working template that developers can copy for new features, with documented CQRS guidelines.
Output: Full Category CRUD slice, CQRS guidelines document.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-project-structure/01-CONTEXT.md
@.planning/phases/01-foundation-project-structure/01-RESEARCH.md
@code/BuildingBlocks/BuildingBlocks.Common/BaseAggregateRoot.cs
@code/BuildingBlocks/BuildingBlocks.Common/StronglyTypedId.cs
@code/BuildingBlocks/BuildingBlocks.Common/ValueObject.cs
@code/BuildingBlocks/BuildingBlocks.Common/Events/DomainEvent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Category domain model</name>
  <files>
code/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Category.cs
code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/CategoryId.cs
code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/CategoryName.cs
code/MicroCommerce.ApiService/Features/Catalog/Domain/Events/CategoryCreatedDomainEvent.cs
  </files>
  <action>
Create the Catalog domain model as a reference implementation:

**CategoryId.cs:**
```csharp
using MicroCommerce.BuildingBlocks.Common;

namespace MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;

public sealed record CategoryId : StronglyTypedId<Guid>
{
    public CategoryId(Guid value) : base(value) { }

    public static CategoryId New() => new(Guid.NewGuid());
    public static CategoryId From(Guid value) => new(value);
}
```

**CategoryName.cs:**
```csharp
using Ardalis.GuardClauses;
using MicroCommerce.BuildingBlocks.Common;

namespace MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;

public sealed class CategoryName : ValueObject
{
    public string Value { get; }

    private CategoryName(string value)
    {
        Value = value;
    }

    public static CategoryName From(string value)
    {
        Guard.Against.NullOrWhiteSpace(value, nameof(value));
        Guard.Against.LengthOutOfRange(value, 1, 100, nameof(value));
        return new CategoryName(value.Trim());
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }
}
```

**CategoryCreatedDomainEvent.cs:**
```csharp
using MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;
using MicroCommerce.BuildingBlocks.Common.Events;

namespace MicroCommerce.ApiService.Features.Catalog.Domain.Events;

/// <summary>
/// Thin event - carries only ID, consumers fetch details when needed.
/// </summary>
public record CategoryCreatedDomainEvent(CategoryId CategoryId) : DomainEvent;
```

**Category.cs:**
```csharp
using MicroCommerce.ApiService.Features.Catalog.Domain.Events;
using MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;
using MicroCommerce.BuildingBlocks.Common;

namespace MicroCommerce.ApiService.Features.Catalog.Domain.Entities;

public class Category : BaseAggregateRoot<CategoryId>
{
    public CategoryName Name { get; private set; } = null!;
    public string? Description { get; private set; }
    public DateTimeOffset CreatedAt { get; private set; }

    // EF Core constructor
    private Category(CategoryId id) : base(id) { }

    public static Category Create(CategoryName name, string? description = null)
    {
        var category = new Category(CategoryId.New())
        {
            Name = name,
            Description = description,
            CreatedAt = DateTimeOffset.UtcNow
        };

        category.AddDomainEvent(new CategoryCreatedDomainEvent(category.Id));
        return category;
    }

    public void UpdateName(CategoryName name)
    {
        Name = name;
    }

    public void UpdateDescription(string? description)
    {
        Description = description;
    }
}
```

Key patterns demonstrated:
- StronglyTypedId for type-safe identifiers
- ValueObject for domain concepts with validation
- Factory method pattern for aggregate creation
- Private setters for encapsulation
- Domain event raised in factory
  </action>
  <verify>
Run `dotnet build code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` - should compile.
  </verify>
  <done>
Category domain model created with aggregate, value objects, and domain event.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CQRS command and query structure</name>
  <files>
code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommand.cs
code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandHandler.cs
code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateCategory/CreateCategoryCommandValidator.cs
code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategories/GetCategoriesQuery.cs
code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategories/GetCategoriesQueryHandler.cs
code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategories/CategoryDto.cs
  </files>
  <action>
Create the Application layer with command and query implementations:

**CreateCategoryCommand.cs:**
```csharp
using MediatR;
using MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;

namespace MicroCommerce.ApiService.Features.Catalog.Application.Commands.CreateCategory;

public record CreateCategoryCommand(
    string Name,
    string? Description) : IRequest<CategoryId>;
```

**CreateCategoryCommandValidator.cs:**
```csharp
using FluentValidation;

namespace MicroCommerce.ApiService.Features.Catalog.Application.Commands.CreateCategory;

public class CreateCategoryCommandValidator : AbstractValidator<CreateCategoryCommand>
{
    public CreateCategoryCommandValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Category name is required")
            .MaximumLength(100).WithMessage("Category name must not exceed 100 characters");
    }
}
```

**CreateCategoryCommandHandler.cs:**
```csharp
using MediatR;
using MicroCommerce.ApiService.Features.Catalog.Domain.Entities;
using MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;
using MicroCommerce.ApiService.Features.Catalog.Infrastructure;

namespace MicroCommerce.ApiService.Features.Catalog.Application.Commands.CreateCategory;

public class CreateCategoryCommandHandler : IRequestHandler<CreateCategoryCommand, CategoryId>
{
    private readonly CatalogDbContext _context;

    public CreateCategoryCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<CategoryId> Handle(
        CreateCategoryCommand request,
        CancellationToken cancellationToken)
    {
        var category = Category.Create(
            CategoryName.From(request.Name),
            request.Description);

        _context.Categories.Add(category);
        await _context.SaveChangesAsync(cancellationToken);

        return category.Id;
    }
}
```

**CategoryDto.cs:**
```csharp
namespace MicroCommerce.ApiService.Features.Catalog.Application.Queries.GetCategories;

public record CategoryDto(
    Guid Id,
    string Name,
    string? Description,
    DateTimeOffset CreatedAt);
```

**GetCategoriesQuery.cs:**
```csharp
using MediatR;

namespace MicroCommerce.ApiService.Features.Catalog.Application.Queries.GetCategories;

public record GetCategoriesQuery : IRequest<IReadOnlyList<CategoryDto>>;
```

**GetCategoriesQueryHandler.cs:**
```csharp
using MediatR;
using Microsoft.EntityFrameworkCore;
using MicroCommerce.ApiService.Features.Catalog.Infrastructure;

namespace MicroCommerce.ApiService.Features.Catalog.Application.Queries.GetCategories;

public class GetCategoriesQueryHandler : IRequestHandler<GetCategoriesQuery, IReadOnlyList<CategoryDto>>
{
    private readonly CatalogDbContext _context;

    public GetCategoriesQueryHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<IReadOnlyList<CategoryDto>> Handle(
        GetCategoriesQuery request,
        CancellationToken cancellationToken)
    {
        return await _context.Categories
            .Select(c => new CategoryDto(
                c.Id.Value,
                c.Name.Value,
                c.Description,
                c.CreatedAt))
            .ToListAsync(cancellationToken);
    }
}
```

Key patterns demonstrated:
- Separate Command and Query types
- One handler per command/query
- Validator per command (queries don't typically need validation)
- DTOs for query responses (not domain entities)
  </action>
  <verify>
Run `dotnet build code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` - should compile.
  </verify>
  <done>
CQRS command and query structure created with handler and validator.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up DbContext, EF configuration, and endpoints</name>
  <files>
code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/CatalogDbContext.cs
code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/CategoryConfiguration.cs
code/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
code/MicroCommerce.ApiService/Program.cs
  </files>
  <action>
Update CatalogDbContext, add EF configuration, create minimal API endpoints:

**Update CatalogDbContext.cs** to add Categories DbSet:
```csharp
using MicroCommerce.ApiService.Features.Catalog.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace MicroCommerce.ApiService.Features.Catalog.Infrastructure;

public class CatalogDbContext : DbContext
{
    public CatalogDbContext(DbContextOptions<CatalogDbContext> options)
        : base(options)
    {
    }

    public DbSet<Category> Categories => Set<Category>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.HasDefaultSchema("catalog");
        modelBuilder.ApplyConfigurationsFromAssembly(
            typeof(CatalogDbContext).Assembly,
            t => t.Namespace?.Contains("Features.Catalog") == true);
    }
}
```

**CategoryConfiguration.cs:**
```csharp
using MicroCommerce.ApiService.Features.Catalog.Domain.Entities;
using MicroCommerce.ApiService.Features.Catalog.Domain.ValueObjects;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace MicroCommerce.ApiService.Features.Catalog.Infrastructure.Configurations;

public class CategoryConfiguration : IEntityTypeConfiguration<Category>
{
    public void Configure(EntityTypeBuilder<Category> builder)
    {
        builder.ToTable("Categories");

        builder.HasKey(c => c.Id);

        builder.Property(c => c.Id)
            .HasConversion(
                id => id.Value,
                value => CategoryId.From(value));

        builder.Property(c => c.Name)
            .HasConversion(
                name => name.Value,
                value => CategoryName.From(value))
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(c => c.Description)
            .HasMaxLength(500);
    }
}
```

**CatalogEndpoints.cs:**
```csharp
using MediatR;
using MicroCommerce.ApiService.Features.Catalog.Application.Commands.CreateCategory;
using MicroCommerce.ApiService.Features.Catalog.Application.Queries.GetCategories;

namespace MicroCommerce.ApiService.Features.Catalog;

public static class CatalogEndpoints
{
    public static void MapCatalogEndpoints(this IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/api/catalog")
            .WithTags("Catalog");

        group.MapPost("/categories", async (
            CreateCategoryCommand command,
            ISender sender,
            CancellationToken cancellationToken) =>
        {
            var categoryId = await sender.Send(command, cancellationToken);
            return Results.Created($"/api/catalog/categories/{categoryId.Value}", new { id = categoryId.Value });
        })
        .WithName("CreateCategory");

        group.MapGet("/categories", async (
            ISender sender,
            CancellationToken cancellationToken) =>
        {
            var categories = await sender.Send(new GetCategoriesQuery(), cancellationToken);
            return Results.Ok(categories);
        })
        .WithName("GetCategories");
    }
}
```

**Update Program.cs** to map catalog endpoints - add before `app.Run()`:
```csharp
using MicroCommerce.ApiService.Features.Catalog;

// ... existing code ...

app.MapCatalogEndpoints();

app.Run();
```
  </action>
  <verify>
Run `dotnet build code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj` - should compile.
  </verify>
  <done>
Category endpoints wired to MediatR commands/queries via minimal API.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create CQRS usage guidelines document</name>
  <files>.planning/phases/01-foundation-project-structure/CQRS-GUIDELINES.md</files>
  <action>
Create a developer-facing document explaining CQRS patterns and conventions:

```markdown
# CQRS Usage Guidelines

## Overview

MicroCommerce uses Command Query Responsibility Segregation (CQRS) via MediatR for all application operations. This document establishes patterns and conventions.

## Core Principles

1. **Every operation is a Command or Query** - No direct repository/service calls from endpoints
2. **One handler per command/query** - No shared handlers
3. **Commands modify state, Queries read state** - Never mix
4. **Validation happens in pipeline** - Not in handlers

## Folder Structure

```
Features/
└── {Module}/
    ├── Domain/
    │   ├── Entities/
    │   ├── ValueObjects/
    │   └── Events/
    ├── Application/
    │   ├── Commands/
    │   │   └── {CommandName}/
    │   │       ├── {CommandName}Command.cs
    │   │       ├── {CommandName}CommandHandler.cs
    │   │       └── {CommandName}CommandValidator.cs
    │   └── Queries/
    │       └── {QueryName}/
    │           ├── {QueryName}Query.cs
    │           ├── {QueryName}QueryHandler.cs
    │           └── {Dto}.cs
    ├── Infrastructure/
    │   ├── {Module}DbContext.cs
    │   └── Configurations/
    └── {Module}Endpoints.cs
```

## Naming Conventions

| Type | Pattern | Example |
|------|---------|---------|
| Command | `{Verb}{Entity}Command` | `CreateProductCommand` |
| Command Handler | `{Command}Handler` | `CreateProductCommandHandler` |
| Command Validator | `{Command}Validator` | `CreateProductCommandValidator` |
| Query | `Get{Entity/Entities}Query` | `GetProductsQuery` |
| Query Handler | `{Query}Handler` | `GetProductsQueryHandler` |
| DTO | `{Entity}Dto` | `ProductDto` |
| Domain Event | `{Entity}{Action}DomainEvent` | `ProductCreatedDomainEvent` |

## Command Pattern

```csharp
// Command - represents intent to change state
public record CreateProductCommand(
    string Name,
    decimal Price,
    Guid CategoryId) : IRequest<ProductId>;

// Validator - validates input before handler
public class CreateProductCommandValidator : AbstractValidator<CreateProductCommand>
{
    public CreateProductCommandValidator()
    {
        RuleFor(x => x.Name).NotEmpty().MaximumLength(200);
        RuleFor(x => x.Price).GreaterThan(0);
    }
}

// Handler - executes the command
public class CreateProductCommandHandler : IRequestHandler<CreateProductCommand, ProductId>
{
    public async Task<ProductId> Handle(CreateProductCommand request, CancellationToken ct)
    {
        // Create aggregate via factory method
        var product = Product.Create(
            ProductName.From(request.Name),
            Money.From(request.Price),
            CategoryId.From(request.CategoryId));

        _context.Products.Add(product);
        await _context.SaveChangesAsync(ct);

        return product.Id;
    }
}
```

## Query Pattern

```csharp
// Query - request for data
public record GetProductQuery(Guid Id) : IRequest<ProductDto?>;

// Handler - returns DTO, not domain entity
public class GetProductQueryHandler : IRequestHandler<GetProductQuery, ProductDto?>
{
    public async Task<ProductDto?> Handle(GetProductQuery request, CancellationToken ct)
    {
        return await _context.Products
            .Where(p => p.Id.Value == request.Id)
            .Select(p => new ProductDto(
                p.Id.Value,
                p.Name.Value,
                p.Price.Amount))
            .FirstOrDefaultAsync(ct);
    }
}
```

## Domain Events

Domain events are thin (IDs only) and published via MassTransit outbox:

```csharp
// Event definition - carries minimal data
public record ProductCreatedDomainEvent(ProductId ProductId) : DomainEvent;

// Aggregate raises event in factory
public static Product Create(...)
{
    var product = new Product(...);
    product.AddDomainEvent(new ProductCreatedDomainEvent(product.Id));
    return product;
}

// Consumer (in another module) handles event
public class ProductCreatedConsumer : IConsumer<ProductCreatedDomainEvent>
{
    public async Task Consume(ConsumeContext<ProductCreatedDomainEvent> context)
    {
        // Fetch product details if needed, then process
    }
}
```

## Anti-Patterns to Avoid

❌ **Don't** call DbContext directly from endpoints
❌ **Don't** share handlers between commands
❌ **Don't** validate in handlers (use validators)
❌ **Don't** return domain entities from queries
❌ **Don't** put business logic in validators
❌ **Don't** include full entity data in domain events

✅ **Do** use MediatR Send for all operations
✅ **Do** one handler per command/query
✅ **Do** validate with FluentValidation
✅ **Do** return DTOs from queries
✅ **Do** put business logic in domain entities
✅ **Do** keep domain events thin (IDs only)

## Creating a New Feature

1. Create folder structure: `Features/{Module}/Domain/`, `Application/`, `Infrastructure/`
2. Create domain entities and value objects
3. Create DbContext with schema isolation
4. Create Command + Handler + Validator for writes
5. Create Query + Handler + DTO for reads
6. Create endpoints that use ISender
7. Add EF Core configuration for entities
```
  </action>
  <verify>
File exists at `.planning/phases/01-foundation-project-structure/CQRS-GUIDELINES.md`
  </verify>
  <done>
CQRS guidelines document created for developer reference.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build code/MicroCommerce.ApiService/` compiles without errors
2. Category domain model follows DDD patterns (aggregate, value objects, domain events)
3. CQRS structure has Command/Query/Handler/Validator in expected locations
4. Endpoints use ISender.Send() for all operations
5. CQRS-GUIDELINES.md provides clear patterns for developers
</verification>

<success_criteria>
- Category feature demonstrates complete CQRS pattern
- POST /api/catalog/categories creates category via command
- GET /api/catalog/categories returns categories via query
- Validation fails fast with structured error response
- Domain event raised when category created
- CQRS guidelines document ready for developer reference
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-project-structure/01-05-SUMMARY.md`
</output>
