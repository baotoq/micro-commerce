---
phase: 05-event-bus-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - code/MicroCommerce.ApiService/Common/Messaging/DeadLetterQueueService.cs
  - code/MicroCommerce.ApiService/Features/Messaging/Application/GetDeadLetterMessagesQuery.cs
  - code/MicroCommerce.ApiService/Features/Messaging/Application/RetryDeadLetterMessageCommand.cs
  - code/MicroCommerce.ApiService/Features/Messaging/Application/PurgeDeadLetterMessagesCommand.cs
  - code/MicroCommerce.ApiService/Features/Messaging/MessagingEndpoints.cs
  - code/MicroCommerce.ApiService/Program.cs
autonomous: true

must_haves:
  truths:
    - "Admin can retrieve a list of dead-lettered messages with type, error, correlation, and timestamp"
    - "Admin can retry a dead-lettered message (re-send to original queue)"
    - "Admin can purge all dead-lettered messages from a queue"
    - "Warning-level structured log emitted when a message faults (DLQ entry)"
  artifacts:
    - path: "code/MicroCommerce.ApiService/Common/Messaging/DeadLetterQueueService.cs"
      provides: "DLQ browse/retry/purge operations via Azure Service Bus SDK"
      exports: ["DeadLetterQueueService", "IDeadLetterQueueService"]
    - path: "code/MicroCommerce.ApiService/Features/Messaging/Application/GetDeadLetterMessagesQuery.cs"
      provides: "CQRS query to list DLQ messages"
      exports: ["GetDeadLetterMessagesQuery"]
    - path: "code/MicroCommerce.ApiService/Features/Messaging/Application/RetryDeadLetterMessageCommand.cs"
      provides: "CQRS command to retry a single DLQ message"
      exports: ["RetryDeadLetterMessageCommand"]
    - path: "code/MicroCommerce.ApiService/Features/Messaging/Application/PurgeDeadLetterMessagesCommand.cs"
      provides: "CQRS command to purge DLQ messages"
      exports: ["PurgeDeadLetterMessagesCommand"]
    - path: "code/MicroCommerce.ApiService/Features/Messaging/MessagingEndpoints.cs"
      provides: "Admin API endpoints for DLQ management"
      contains: "MapMessagingEndpoints"
  key_links:
    - from: "MessagingEndpoints"
      to: "MediatR ISender"
      via: "Send query/command"
      pattern: "sender\\.Send"
    - from: "Query/Command handlers"
      to: "IDeadLetterQueueService"
      via: "DI injection"
      pattern: "IDeadLetterQueueService"
    - from: "DeadLetterQueueService"
      to: "Azure Service Bus SDK"
      via: "ServiceBusClient"
      pattern: "ServiceBusClient"
---

<objective>
Create the DLQ management backend: a service that uses Azure Service Bus SDK to browse/retry/purge dead-lettered messages, CQRS queries/commands following project conventions, API endpoints, and a fault consumer for DLQ logging.

Purpose: Enable programmatic access to dead-lettered messages for admin visibility and recovery.
Output: DeadLetterQueueService, CQRS handlers, API endpoints at /api/messaging/dead-letters.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-event-bus-infrastructure/05-RESEARCH.md
@.planning/phases/05-event-bus-infrastructure/05-CONTEXT.md
@.planning/phases/05-event-bus-infrastructure/05-01-SUMMARY.md
@code/MicroCommerce.ApiService/Program.cs
@code/MicroCommerce.AppHost/AppHost.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: DeadLetterQueueService and ServiceBusClient registration</name>
  <files>
    code/MicroCommerce.ApiService/Common/Messaging/DeadLetterQueueService.cs
    code/MicroCommerce.ApiService/Program.cs
  </files>
  <action>
1. Create `IDeadLetterQueueService` interface and `DeadLetterQueueService` class in `Common/Messaging/DeadLetterQueueService.cs`:

   Namespace: `MicroCommerce.ApiService.Common.Messaging`

   Interface methods:
   - `Task<IReadOnlyList<DeadLetterMessageDto>> PeekDeadLettersAsync(string queueName, int maxMessages = 20, CancellationToken ct = default)`
   - `Task RetryDeadLetterAsync(string queueName, long sequenceNumber, CancellationToken ct = default)`
   - `Task<int> PurgeDeadLettersAsync(string queueName, CancellationToken ct = default)`
   - `Task<IReadOnlyList<string>> GetQueueNamesAsync(CancellationToken ct = default)` -- returns known consumer queue names

   DTO record:
   ```
   public record DeadLetterMessageDto(
       long SequenceNumber,
       string MessageType,
       string ErrorDescription,
       string? CorrelationId,
       DateTimeOffset EnqueuedTime,
       string QueueName);
   ```

   Implementation:
   - Inject `ServiceBusClient` via constructor
   - `PeekDeadLettersAsync`: Create receiver for `{queueName}/$deadletterqueue` using `_client.CreateReceiver(queueName, new ServiceBusReceiverOptions { SubQueue = SubQueue.DeadLetter })`. Peek messages, map to DTO. Extract message type from `ApplicationProperties["MT-MessageType"]` or body. Extract error from `DeadLetterReason` property. Extract CorrelationId from `ApplicationProperties["MT-Activity-CorrelationId"]` or `CorrelationId`.
   - `RetryDeadLetterAsync`: Receive specific message by sequence number from DLQ, re-send to original queue via sender, complete original message.
   - `PurgeDeadLettersAsync`: Receive messages in batches and complete them. Return count purged.
   - `GetQueueNamesAsync`: Return hardcoded list of known MassTransit consumer queue names. MassTransit names queues based on consumer class name (kebab-case). For `ProductCreatedConsumer` consuming `ProductCreatedDomainEvent`, the queue name is typically the message type name. Use `product-created-domain-event` as the queue name (MassTransit default formatting). This list will grow as more consumers are added in future phases.
   - Dispose receivers after use (use `await using`).

2. Register `ServiceBusClient` and `DeadLetterQueueService` in `Program.cs`:
   - Check if Aspire's `AddAzureServiceBus` already registers `ServiceBusClient`. If not, register one manually using the "messaging" connection string:
     ```
     builder.Services.AddSingleton(sp =>
     {
         var connectionString = builder.Configuration.GetConnectionString("messaging");
         return new ServiceBusClient(connectionString);
     });
     ```
   - Register: `builder.Services.AddScoped<IDeadLetterQueueService, DeadLetterQueueService>();`
   - Add `using Azure.Messaging.ServiceBus;` if needed.
   - Ensure `Azure.Messaging.ServiceBus` NuGet package is referenced. Check if it comes transitively from `Aspire.Azure.Messaging.ServiceBus`. If not: `dotnet add code/MicroCommerce.ApiService package Azure.Messaging.ServiceBus`.

   NOTE: The Azure Service Bus emulator may not fully support DLQ sub-queues. The service should handle ServiceBusException gracefully and log warnings if DLQ operations fail in the emulator environment.
  </action>
  <verify>
    `dotnet build code/` succeeds with no errors.
  </verify>
  <done>
    DeadLetterQueueService exists with peek/retry/purge operations. ServiceBusClient registered in DI. Service registered in Program.cs.
  </done>
</task>

<task type="auto">
  <name>Task 2: CQRS handlers, API endpoints, and fault consumer</name>
  <files>
    code/MicroCommerce.ApiService/Features/Messaging/Application/GetDeadLetterMessagesQuery.cs
    code/MicroCommerce.ApiService/Features/Messaging/Application/RetryDeadLetterMessageCommand.cs
    code/MicroCommerce.ApiService/Features/Messaging/Application/PurgeDeadLetterMessagesCommand.cs
    code/MicroCommerce.ApiService/Features/Messaging/MessagingEndpoints.cs
    code/MicroCommerce.ApiService/Common/Messaging/DomainEventFaultConsumer.cs
    code/MicroCommerce.ApiService/Program.cs
  </files>
  <action>
1. Create `GetDeadLetterMessagesQuery.cs`:
   - Record: `GetDeadLetterMessagesQuery(string? QueueName = null, int MaxMessages = 20) : IRequest<GetDeadLetterMessagesResponse>`
   - Response: `record GetDeadLetterMessagesResponse(IReadOnlyList<DeadLetterMessageDto> Messages, IReadOnlyList<string> QueueNames)`
   - Handler injects `IDeadLetterQueueService`. If QueueName is null, peek from all known queues and combine results. If QueueName specified, peek from that queue only. Always return available queue names for the UI dropdown.

2. Create `RetryDeadLetterMessageCommand.cs`:
   - Record: `RetryDeadLetterMessageCommand(string QueueName, long SequenceNumber) : IRequest`
   - Handler injects `IDeadLetterQueueService`, calls `RetryDeadLetterAsync`.

3. Create `PurgeDeadLetterMessagesCommand.cs`:
   - Record: `PurgeDeadLetterMessagesCommand(string QueueName) : IRequest<int>`
   - Handler injects `IDeadLetterQueueService`, calls `PurgeDeadLettersAsync`, returns count.

4. Create `MessagingEndpoints.cs` following existing endpoint patterns (see CatalogEndpoints.cs, InventoryEndpoints.cs):
   - Static class with `MapMessagingEndpoints(this WebApplication app)` extension method
   - Route group: `app.MapGroup("/api/messaging")` with `.WithTags("Messaging")`
   - Endpoints:
     - `GET /api/messaging/dead-letters?queueName={name}&maxMessages={n}` -> GetDeadLetterMessagesQuery
     - `POST /api/messaging/dead-letters/retry` with body `{ queueName, sequenceNumber }` -> RetryDeadLetterMessageCommand
     - `POST /api/messaging/dead-letters/purge` with body `{ queueName }` -> PurgeDeadLetterMessagesCommand
   - All endpoints should `.RequireAuthorization()` (admin-only)

5. Create `DomainEventFaultConsumer.cs` in `Common/Messaging/`:
   - Generic open type: `DomainEventFaultConsumer<T> : IConsumer<Fault<T>> where T : class`
   - Log at Warning level: message type, faulted message ID, correlation ID, exception messages
   - This provides structured warning logs when messages fault (visible in Aspire dashboard)
   - Register in MassTransit: MassTransit auto-discovers fault consumers via `AddConsumers(typeof(Program).Assembly)` since it's in the assembly.

6. In `Program.cs`:
   - Add `app.MapMessagingEndpoints();` in the endpoint mapping section (after `app.MapInventoryEndpoints()`)
  </action>
  <verify>
    `dotnet build code/` succeeds with no errors.
  </verify>
  <done>
    Three CQRS handlers for DLQ operations exist. API endpoints mapped at /api/messaging/dead-letters. DomainEventFaultConsumer logs warnings on message faults. MessagingEndpoints registered in Program.cs.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build code/` compiles without errors
2. Grep for `MapMessagingEndpoints` in Program.cs confirms endpoint registration
3. Grep for `IDeadLetterQueueService` confirms service interface exists
4. Grep for `DomainEventFaultConsumer` confirms fault consumer exists
5. Grep for `ServiceBusClient` in Program.cs or DeadLetterQueueService confirms SDK usage
6. Files exist: GetDeadLetterMessagesQuery.cs, RetryDeadLetterMessageCommand.cs, PurgeDeadLetterMessagesCommand.cs
</verification>

<success_criteria>
- Solution builds cleanly
- DLQ service can peek, retry, and purge dead-lettered messages
- CQRS pattern followed for all DLQ operations
- API endpoints protected with authorization
- Fault consumer logs warnings with correlation context
- All endpoints accessible at /api/messaging/dead-letters
</success_criteria>

<output>
After completion, create `.planning/phases/05-event-bus-infrastructure/05-02-SUMMARY.md`
</output>
