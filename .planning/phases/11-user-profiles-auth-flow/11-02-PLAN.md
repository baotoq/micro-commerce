---
phase: 11-user-profiles-auth-flow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/MicroCommerce.ApiService/Features/Cart/Application/Commands/MergeCarts/MergeCartsCommand.cs
  - src/MicroCommerce.ApiService/Features/Cart/Application/Commands/MergeCarts/MergeCartsCommandHandler.cs
  - src/MicroCommerce.ApiService/Features/Cart/CartEndpoints.cs
  - src/MicroCommerce.ApiService/Features/Cart/Domain/Entities/Cart.cs
  - src/MicroCommerce.Web/src/auth.ts
  - src/MicroCommerce.Web/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "Guest cart items merge into authenticated user's cart on login"
    - "Quantities combine for same products during merge"
    - "Guest cart is deleted after successful merge"
    - "User stays on the current page after login (no redirect)"
  artifacts:
    - path: "src/MicroCommerce.ApiService/Features/Cart/Application/Commands/MergeCarts/MergeCartsCommand.cs"
      provides: "Cart merge command record"
      contains: "MergeCartsCommand"
    - path: "src/MicroCommerce.ApiService/Features/Cart/Application/Commands/MergeCarts/MergeCartsCommandHandler.cs"
      provides: "Cart merge logic"
      contains: "MergeCartsCommandHandler"
    - path: "src/MicroCommerce.ApiService/Features/Cart/CartEndpoints.cs"
      provides: "POST /api/cart/merge endpoint"
      contains: "MergeCarts"
    - path: "src/MicroCommerce.Web/src/auth.ts"
      provides: "Cart merge trigger on login"
      contains: "cart/merge"
  key_links:
    - from: "auth.ts"
      to: "/api/cart/merge"
      via: "fetch in signIn event callback"
      pattern: "cart/merge"
    - from: "MergeCartsCommandHandler.cs"
      to: "CartDbContext"
      via: "EF Core query"
      pattern: "_context.Carts"
---

<objective>
Implement guest-to-authenticated cart merge triggered on login.

Purpose: When a guest user logs in, their cart items must seamlessly transfer to their authenticated account without data loss. This is a critical user experience requirement (PROF-08).
Output: MergeCartsCommand + handler in Cart module, merge API endpoint, NextAuth callback integration.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-user-profiles-auth-flow/11-RESEARCH.md

@src/MicroCommerce.ApiService/Features/Cart/Domain/Entities/Cart.cs
@src/MicroCommerce.ApiService/Features/Cart/CartEndpoints.cs
@src/MicroCommerce.ApiService/Features/Cart/BuyerIdentity.cs
@src/MicroCommerce.ApiService/Features/Cart/Infrastructure/CartDbContext.cs
@src/MicroCommerce.Web/src/auth.ts
@src/MicroCommerce.Web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TransferOwnership to Cart aggregate and create MergeCartsCommand</name>
  <files>
    src/MicroCommerce.ApiService/Features/Cart/Domain/Entities/Cart.cs
    src/MicroCommerce.ApiService/Features/Cart/Application/Commands/MergeCarts/MergeCartsCommand.cs
    src/MicroCommerce.ApiService/Features/Cart/Application/Commands/MergeCarts/MergeCartsCommandHandler.cs
    src/MicroCommerce.ApiService/Features/Cart/CartEndpoints.cs
  </files>
  <action>
    **Cart.cs - Add TransferOwnership method:**
    Add a public method to the Cart aggregate:
    ```csharp
    /// <summary>
    /// Transfers cart ownership to a different buyer (used during guest-to-auth merge).
    /// </summary>
    public void TransferOwnership(Guid newBuyerId)
    {
        BuyerId = newBuyerId;
        Touch();
    }
    ```

    **MergeCartsCommand.cs:**
    ```csharp
    public sealed record MergeCartsCommand(Guid GuestBuyerId, Guid AuthenticatedBuyerId) : IRequest;
    ```
    Namespace: `MicroCommerce.ApiService.Features.Cart.Application.Commands.MergeCarts`

    **MergeCartsCommandHandler.cs:**
    Handler that implements IRequestHandler<MergeCartsCommand>.
    Constructor inject CartDbContext.
    Logic:
    1. Load guest cart with Items included, filtered by GuestBuyerId. If null or no items, return early (no-op).
    2. Load auth cart with Items included, filtered by AuthenticatedBuyerId.
    3. If auth cart is null: call `guestCart.TransferOwnership(request.AuthenticatedBuyerId)` to just reassign the cart.
    4. If auth cart exists: iterate guest cart items, call `authCart.AddItem(guestItem.ProductId, guestItem.ProductName, guestItem.UnitPrice, guestItem.ImageUrl, guestItem.Quantity)` for each. Then `_context.Carts.Remove(guestCart)`.
    5. `await _context.SaveChangesAsync(cancellationToken)`.

    **CartEndpoints.cs - Add merge endpoint:**
    Add a new POST endpoint to the existing group:
    ```csharp
    group.MapPost("/merge", MergeCarts)
        .WithName("MergeCarts")
        .WithSummary("Merge guest cart into authenticated user's cart")
        .RequireAuthorization()
        .Produces(StatusCodes.Status204NoContent);
    ```

    Add the handler method:
    ```csharp
    private static async Task<IResult> MergeCarts(
        MergeCartsRequest request,
        HttpContext httpContext,
        ISender sender,
        CancellationToken cancellationToken)
    {
        // Get authenticated user ID from claims
        var sub = httpContext.User.FindFirstValue(ClaimTypes.NameIdentifier)
                  ?? httpContext.User.FindFirstValue("sub");

        if (string.IsNullOrEmpty(sub) || !Guid.TryParse(sub, out var authenticatedBuyerId))
        {
            return Results.Unauthorized();
        }

        var command = new MergeCartsCommand(request.GuestBuyerId, authenticatedBuyerId);
        await sender.Send(command, cancellationToken);

        return Results.NoContent();
    }
    ```

    Add request record at the bottom of CartEndpoints.cs:
    ```csharp
    public sealed record MergeCartsRequest(Guid GuestBuyerId);
    ```

    Add needed using for MergeCartsCommand namespace.
  </action>
  <verify>
    `dotnet build src/MicroCommerce.ApiService` compiles without errors. The merge endpoint is registered in CartEndpoints.
  </verify>
  <done>
    Cart aggregate has TransferOwnership method. MergeCartsCommand merges guest cart into auth cart (combining quantities for same products). POST /api/cart/merge endpoint requires authorization and accepts guest buyer ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate cart merge into NextAuth login flow</name>
  <files>
    src/MicroCommerce.Web/src/auth.ts
    src/MicroCommerce.Web/src/lib/api.ts
  </files>
  <action>
    **api.ts - Add mergeCart function:**
    Add at the end of the Cart API functions section:
    ```typescript
    export async function mergeCart(guestBuyerId: string, accessToken: string): Promise<void> {
      const response = await fetch(`${API_BASE}/api/cart/merge`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${accessToken}`,
        },
        body: JSON.stringify({ guestBuyerId }),
      });

      if (!response.ok) {
        // Merge is best-effort; don't throw on failure
        console.error("Failed to merge cart:", response.status);
      }
    }
    ```

    **auth.ts - Add signIn event for cart merge:**
    The cart merge needs to happen server-side during the NextAuth flow. Since the `buyer_id` cookie is HttpOnly, we cannot read it from the client directly. Instead, we need to use the NextAuth `events.signIn` callback which runs server-side and can read cookies via the request context.

    However, NextAuth v5 events don't have access to the request context directly. The better approach is to use a combination:

    1. In the `jwt` callback (which runs on sign-in), when `account` is present (meaning fresh login), set a flag `token.justLoggedIn = true` on the token.
    2. Create a client-side hook or component that detects fresh login and triggers the merge.

    Actually, the simplest reliable approach: use the `events.signIn` callback which does fire server-side. But reading cookies there requires the request object.

    **Preferred approach - client-side merge trigger:**

    Update auth.ts to mark when a user just signed in:
    ```typescript
    callbacks: {
      async jwt({ token, account }) {
        if (account) {
          token.accessToken = account.access_token;
          token.idToken = account.id_token;
          token.refreshToken = account.refresh_token;
          token.expiresAt = account.expires_at;
          token.isNewLogin = true;  // Flag for cart merge
        } else {
          token.isNewLogin = false;
        }
        return token;
      },
      async session({ session, token }) {
        session.accessToken = token.accessToken as string;
        session.isNewLogin = token.isNewLogin as boolean;
        return session;
      },
    },
    ```

    Then update the existing `next-auth.d.ts` types to include `isNewLogin`:
    - Add `isNewLogin?: boolean` to Session interface extension

    The actual cart merge will be triggered from the frontend in Plan 04/05 when the header auth integration happens. For now, ensure the session flag and API function exist.

    Actually, the simplest approach that works with HttpOnly cookies: the buyer_id cookie is sent with all requests to the API. So the merge endpoint can simply read the cookie on the server side instead of requiring the client to pass the guest buyer ID.

    **Revised approach - server-side cookie reading:**

    Update the CartEndpoints MergeCarts handler to read the buyer_id cookie directly instead of requiring it in the request body:
    ```csharp
    private static async Task<IResult> MergeCarts(
        HttpContext httpContext,
        ISender sender,
        CancellationToken cancellationToken)
    {
        var sub = httpContext.User.FindFirstValue(ClaimTypes.NameIdentifier)
                  ?? httpContext.User.FindFirstValue("sub");

        if (string.IsNullOrEmpty(sub) || !Guid.TryParse(sub, out var authenticatedBuyerId))
            return Results.Unauthorized();

        // Read guest buyer_id from cookie
        if (!httpContext.Request.Cookies.TryGetValue("buyer_id", out var cookieValue)
            || !Guid.TryParse(cookieValue, out var guestBuyerId))
            return Results.NoContent(); // No guest cart to merge

        // Don't merge if guest and auth IDs are the same
        if (guestBuyerId == authenticatedBuyerId)
            return Results.NoContent();

        await sender.Send(new MergeCartsCommand(guestBuyerId, authenticatedBuyerId), cancellationToken);

        // Clear the guest cookie after merge
        httpContext.Response.Cookies.Delete("buyer_id");

        return Results.NoContent();
    }
    ```

    Update the endpoint registration to remove the request body requirement:
    ```csharp
    group.MapPost("/merge", MergeCarts)
        .WithName("MergeCarts")
        .WithSummary("Merge guest cart into authenticated user's cart")
        .RequireAuthorization()
        .Produces(StatusCodes.Status204NoContent);
    ```

    Remove the MergeCartsRequest record since it's no longer needed.

    **api.ts - Simplified mergeCart function (no body needed):**
    ```typescript
    export async function mergeCart(accessToken: string): Promise<void> {
      const response = await fetch(`${API_BASE}/api/cart/merge`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
        },
        credentials: "include",  // Send cookies (buyer_id)
      });

      if (!response.ok) {
        console.error("Failed to merge cart:", response.status);
      }
    }
    ```

    **auth.ts - Add signIn event:**
    Add an `events` property to the NextAuth config:
    ```typescript
    events: {
      async signIn({ account }) {
        // Cart merge happens client-side after session is established
        // The isNewLogin flag triggers the merge from the header component
      },
    },
    ```

    Actually, the cleanest approach: modify the jwt callback to set isNewLogin flag, and the header component (Plan 04) will call mergeCart on detecting a new login. Update auth.ts jwt callback to set `token.isNewLogin = true` when `account` is present. Update session callback to pass `session.isNewLogin = token.isNewLogin as boolean`. Update `next-auth.d.ts` to add the field.

    For THIS plan, make the following changes only:
    1. In auth.ts: Add `token.isNewLogin = true` in jwt when account present, `token.isNewLogin = false` in else branch. Add `session.isNewLogin = token.isNewLogin as boolean` in session callback.
    2. In next-auth.d.ts: Add `isNewLogin?: boolean` to Session interface.
    3. In api.ts: Add `mergeCart(accessToken: string)` function.

    The actual cart merge call from the UI will be wired in Plan 04 (header account icon integration).
  </action>
  <verify>
    `dotnet build src/MicroCommerce.ApiService` compiles. `cd src/MicroCommerce.Web && npx tsc --noEmit` type-checks. The mergeCart function exists in api.ts. The isNewLogin flag is set in auth.ts.
  </verify>
  <done>
    MergeCartsCommand transfers guest cart items to authenticated user's cart. POST /api/cart/merge reads buyer_id cookie server-side and clears it after merge. Frontend auth.ts sets isNewLogin session flag. api.ts has mergeCart function ready for UI integration.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/MicroCommerce.ApiService` compiles with zero errors
2. Cart.cs has TransferOwnership method
3. MergeCartsCommandHandler merges items with quantity combination
4. CartEndpoints has /merge endpoint with RequireAuthorization
5. auth.ts sets isNewLogin flag on fresh login
6. api.ts has mergeCart function
</verification>

<success_criteria>
- Cart merge command correctly handles: no guest cart (no-op), no auth cart (transfer), both carts exist (merge items + delete guest)
- Endpoint reads buyer_id cookie directly (no client-side cookie reading needed)
- Guest cookie cleared after merge
- Session isNewLogin flag available for UI trigger
- Both backend and frontend compile
</success_criteria>

<output>
After completion, create `.planning/phases/11-user-profiles-auth-flow/11-02-SUMMARY.md`
</output>
