# DDD Audit Findings (Work in Progress)

## BuildingBlocks/Common Foundation

### [Warning] Missing Base Entity class for child entities
- **Issue:** No `Entity<TId>` base class exists for child entities like OrderItem and CartItem. Child entities must implement identity management manually without framework support.
- **Principle:** Entity base classes should provide common identity, equality, and lifecycle behavior for non-aggregate entities (Vernon's Aggregate Design)
- **Reference:** [Microsoft Learn - Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### [Info] DomainEvent.DateOccurred has protected setter
- **Issue:** DomainEvent base class has `DateOccurred` property with a protected setter, allowing derived events to mutate the timestamp after creation
- **Principle:** Domain events should be immutable once created
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Info] BaseAggregateRoot.Id uses init instead of protected init
- **Issue:** The `Id` property uses `init` accessor, allowing initialization from outside the aggregate hierarchy (though primary constructor enforces it)
- **Principle:** Aggregate identity should be fully encapsulated and only settable during construction
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Info] ValueObject caches hash code, which can break mutability guarantees
- **Issue:** ValueObject base class caches hash code in `_cachedHashCode` field, which is an optimization that assumes immutability but doesn't enforce it
- **Principle:** Value objects should be immutable by design, but the implementation relies on convention rather than enforcement
- **Reference:** [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

### [Warning] Obsolete domain event dispatcher infrastructure still present
- **Issue:** The codebase contains obsolete MediatorDomainEventDispatcher, IDomainEventDispatcher, and IDomainEventHandler marked with [Obsolete], but these are still part of the BuildingBlocks API surface
- **Principle:** Dead code should be removed to prevent confusion and accidental usage
- **Reference:** Clean Code principles - remove obsolete infrastructure after migration

## Catalog Module

### [Critical] Product aggregate holds navigation property to Category aggregate
- **Issue:** Product entity has `public Category? Category { get; private set; }` navigation property, creating an object reference to another aggregate root
- **Principle:** Vernon's Rule 3 - Aggregates should reference other aggregates by identity only, not object references
- **Reference:** [Aggregate Design Rules according to Vaughn Vernon](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)

### [Warning] Category not raising domain event on Update
- **Issue:** Category.Update() method changes Name and Description but does not raise a CategoryUpdatedDomainEvent (only CategoryCreatedDomainEvent exists)
- **Principle:** All significant state changes in aggregates should raise domain events to enable eventual consistency and event-driven patterns
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Info] Category has redundant behavior methods
- **Issue:** Category has three update methods: Update(), UpdateName(), and UpdateDescription(), where the latter two are unused granular alternatives to Update()
- **Principle:** Behavior methods should align with actual use cases (YAGNI principle)
- **Reference:** Clean Architecture - avoid speculative generality

### [Warning] ProductStatus is enum, not value object
- **Issue:** ProductStatus is a simple enum rather than a value object with behavior
- **Principle:** Domain concepts with validation rules or behavior should be value objects, not primitive enums
- **Reference:** [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)

### [Critical] UpdateProductCommandHandler returns bool instead of void
- **Issue:** UpdateProductCommandHandler returns `bool` (always true) rather than `void` or `Unit`
- **Principle:** CQRS commands should return void or minimal data (ID only for creation), not success flags
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

### [Warning] Cross-context category existence check in CreateProductCommandHandler
- **Issue:** CreateProductCommandHandler validates CategoryId existence by querying CatalogDbContext.Categories, which is within the same context but represents potential future bounded context boundary violation
- **Principle:** If Category and Product were separate bounded contexts, this check would violate context isolation
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

### [Info] Product.UpdateReviewStats bypasses invariant protection
- **Issue:** Product.UpdateReviewStats() is a public method called by external event handlers (Reviews context), directly mutating denormalized statistics without business rules
- **Principle:** Public aggregate methods should enforce invariants; data synchronization methods could be internal or use a different pattern
- **Reference:** [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### [Warning] Money value object uses class inheritance instead of record struct
- **Issue:** Money is implemented as a sealed class inheriting from ValueObject abstract class, rather than using a readonly record struct (as recommended in ValueObject.cs comments)
- **Principle:** Modern C# (10+) recommends readonly record structs for value objects (immutability by default, structural equality, no heap allocation)
- **Reference:** [Using C# 9 records as strongly-typed ids - Thomas Levesque](https://thomaslevesque.com/2020/10/30/using-csharp-9-records-as-strongly-typed-ids/)

### [Info] ProductName has implicit string conversion operator
- **Issue:** ProductName provides `public static implicit operator string(ProductName name)` for convenience, which can bypass domain logic
- **Principle:** Implicit conversions reduce type safety and can lead to primitive obsession leakage
- **Reference:** Domain-driven design best practices - prefer explicit over implicit conversions

### [Info] Product.Description is plain string, not value object
- **Issue:** Product.Description is a primitive string with no validation or constraints, despite being a domain concept
- **Principle:** Primitive obsession - domain concepts should be modeled as value objects when they have validation rules
- **Reference:** [DDD Anti-patterns - Primitive Obsession](https://alok-mishra.com/2021/11/03/ddd-anti-patterns/)

## Ordering Module

### [Critical] OrderItem has public factory method but no aggregate root protection
- **Issue:** OrderItem.Create() is a public static factory method, allowing OrderItem entities to be created outside the Order aggregate
- **Principle:** Child entities should only be created and managed through their aggregate root to enforce invariants
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] ShippingAddress is a record but does not inherit from ValueObject base class
- **Issue:** ShippingAddress is implemented as a `record` with manual validation, bypassing the ValueObject base class pattern used elsewhere
- **Principle:** Inconsistent value object implementation patterns reduce maintainability
- **Reference:** Consistency in tactical DDD patterns across the codebase

### [Warning] OrderStatus is enum, not value object
- **Issue:** OrderStatus is a simple enum (Submitted, StockReserved, Paid, etc.) without behavior or state transition validation
- **Principle:** Status enums with state machine semantics should be value objects or use the State pattern
- **Reference:** [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)

### [Critical] Order.MarkStockReserved() is public but saga-internal
- **Issue:** Order.MarkStockReserved() is a public method intended only for saga internal transitions, exposing internal state machine details
- **Principle:** Aggregate public API should reflect business operations, not orchestration internals
- **Reference:** [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### [Info] Order calculates business rules (tax, shipping) with hardcoded constants
- **Issue:** Order.Create() uses hardcoded `FlatShippingCost = 5.99m` and `TaxRate = 0.08m` as private constants, not domain services or configuration
- **Principle:** Business rules that change should be externalized to domain services or configuration
- **Reference:** DDD Layered Architecture - business rules vs. technical configuration

### [Warning] Order has no domain event for status transitions beyond Submitted/Paid/Failed
- **Issue:** Order.Confirm(), Order.Ship(), and Order.Deliver() do not raise domain events, preventing event-driven subscribers from reacting to order lifecycle
- **Principle:** All significant state changes should raise domain events for consistency and auditability
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Critical] ReserveStockForOrderConsumer directly queries and mutates Inventory aggregate from Ordering context
- **Issue:** ReserveStockForOrderConsumer (in Ordering.Application) directly injects InventoryDbContext and calls `stockItem.Reserve()`, crossing bounded context boundaries in-process
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration, not direct DbContext access
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html), [Domain analysis for microservices - Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis)

### [Critical] CheckoutState saga state is not an aggregate root
- **Issue:** CheckoutState implements `SagaStateMachineInstance` (MassTransit) but does not inherit from BaseAggregateRoot or implement IAggregateRoot, lacking domain event infrastructure
- **Principle:** Saga state instances with lifecycle and state transitions are conceptually aggregate roots
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] CheckoutState.ReservationIdsJson stores serialized JSON in saga state
- **Issue:** CheckoutState stores `Dictionary<Guid, Guid>` as serialized JSON string for compensation, mixing persistence concern with saga orchestration
- **Principle:** Saga state should use structured data; JSON serialization is a persistence detail
- **Reference:** MassTransit saga best practices - prefer structured properties over serialized blobs

### [Info] Saga contract events (CheckoutStarted, PaymentCompleted, etc.) are not explicitly modeled
- **Issue:** Saga events are referenced by name in CheckoutStateMachine but defined in Contracts.cs (not read in this audit), unclear if they follow domain event conventions
- **Principle:** Saga event contracts should be treated as explicit domain events with clear schemas
- **Reference:** Event-driven architecture best practices

### [Critical] SubmitOrderCommandHandler returns SubmitOrderResult with OrderNumber, violating CQRS
- **Issue:** SubmitOrderCommandHandler returns `SubmitOrderResult(order.Id.Value, order.OrderNumber.Value)` with both ID and OrderNumber
- **Principle:** CQRS commands should return void or creation ID only, not full result objects
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

### [Warning] Order.BuyerId is Guid, not strongly-typed BuyerId
- **Issue:** Order entity uses `Guid BuyerId` primitive instead of a strongly-typed `BuyerId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)

### [Warning] OrderItem.ProductId is Guid, not strongly-typed ProductId
- **Issue:** OrderItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

### [Info] Order.Items collection uses List<OrderItem> internally, exposing IReadOnlyCollection
- **Issue:** Order uses `private readonly List<OrderItem> _items = []` with `IReadOnlyCollection<OrderItem> Items` public property, which is correct, but OrderItem creation still happens outside the aggregate (see OrderItem.Create issue)
- **Principle:** Collection encapsulation is correct, but enforcement of aggregate boundary is incomplete
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

## Cart Module

### [Critical] CartItem has public factory method but no aggregate root protection
- **Issue:** CartItem.Create() is a public static factory method, allowing CartItem entities to be created outside the Cart aggregate
- **Principle:** Child entities should only be created and managed through their aggregate root to enforce invariants (Vernon's Rule 1)
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] Cart.BuyerId is Guid, not strongly-typed BuyerId
- **Issue:** Cart entity uses `Guid BuyerId` primitive instead of a strongly-typed `BuyerId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety and consistency
- **Reference:** [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)

### [Warning] CartItem.ProductId is Guid, not strongly-typed ProductId
- **Issue:** CartItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

### [Warning] Cart does not raise domain events
- **Issue:** Cart aggregate does not raise any domain events for significant operations (item added, item removed, cart transferred)
- **Principle:** All significant state changes should raise domain events for eventual consistency and event-driven patterns
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Info] BuyerIdentity is a static utility class outside domain model
- **Issue:** BuyerIdentity.GetOrCreateBuyerId() is a static utility that mixes infrastructure concerns (cookies, claims) with domain logic (buyer identity)
- **Principle:** Domain concepts should be modeled explicitly; buyer identity resolution could be a domain service
- **Reference:** DDD Layered Architecture - domain services vs. infrastructure utilities

### [Critical] AddToCartCommand returns AddToCartResult with isUpdate flag
- **Issue:** AddToCartCommandHandler returns `AddToCartResult(isUpdate)` with business logic flag, violating CQRS command-query separation
- **Principle:** CQRS commands should return void or creation ID only, not result objects with business state
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

## Inventory Module

### [Warning] StockAdjustment is separate entity, not managed by StockItem aggregate
- **Issue:** StockAdjustment is created independently (likely in handlers), not through StockItem aggregate methods, creating a separate audit trail disconnected from the aggregate
- **Principle:** Related entities in the same consistency boundary should be managed through the aggregate root
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] StockReservation has public factory method but is owned by StockItem
- **Issue:** StockReservation.Create() is a public static factory method, but the entity is owned by StockItem aggregate and created within StockItem.Reserve()
- **Principle:** Child entity factories should be internal or private to prevent external instantiation
- **Reference:** Aggregate boundary enforcement

### [Info] StockItem.AvailableQuantity is a calculated property, not a value object
- **Issue:** AvailableQuantity is a computed property (`QuantityOnHand - active reservations`) without explicit value object modeling
- **Principle:** Domain calculations can be value objects or domain services for richer modeling
- **Reference:** DDD tactical patterns

### [Warning] StockItem.ProductId is Guid, not strongly-typed ProductId
- **Issue:** StockItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

### [Critical] ReserveStockForOrderConsumer (in Ordering) directly queries and mutates Inventory aggregate
- **Issue:** ReserveStockForOrderConsumer (in Ordering.Application) directly injects InventoryDbContext and calls `stockItem.Reserve()`, crossing bounded context boundaries in-process
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration, not direct DbContext access
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

## Profiles Module

### [Critical] Address is modeled as ValueObject but has mutable identity (AddressId)
- **Issue:** Address inherits from ValueObject base class but has an `AddressId` property, mixing entity semantics (identity) with value object semantics (structural equality)
- **Principle:** Value objects are defined by their attributes only, without identity; Address should be an entity if it has identity
- **Reference:** [Value Objects - Martin Fowler](https://martinfowler.com/bliki/ValueObject.html), [Entity vs Value Object - DDD](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)

### [Warning] Address has internal mutators (SetAsDefault, ClearDefault)
- **Issue:** Address has internal methods SetAsDefault() and ClearDefault() that mutate state, contradicting value object immutability principle
- **Principle:** Value objects should be immutable; mutability indicates entity semantics
- **Reference:** [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

### [Info] UserProfile.UpdateAddress replaces address instead of mutating
- **Issue:** UserProfile.UpdateAddress() removes the old address and adds a new one, preserving immutability, but this is inconsistent with Address having an identity (AddressId)
- **Principle:** If Address is an entity (has identity), it should be mutable; if it's a value object, it shouldn't have AddressId
- **Reference:** Entity vs Value Object distinction

### [Warning] UserProfile.UserId is Guid, not strongly-typed UserId
- **Issue:** UserProfile stores `Guid UserId` instead of a strongly-typed `UserId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** Strongly-typed IDs best practices

### [Info] UserProfile does not enforce address limit
- **Issue:** UserProfile allows unlimited addresses with no business rule enforcement (e.g., max 5 addresses)
- **Principle:** Aggregates enforce business invariants; if there's a domain rule, it should be in the aggregate
- **Reference:** Aggregate invariant enforcement

## Reviews Module

### [Critical] Review handlers inject multiple DbContexts (cross-context access)
- **Issue:** CreateReviewCommandHandler, UpdateReviewCommandHandler, and DeleteReviewCommandHandler inject OrderingDbContext and CatalogDbContext to verify purchases and update product ratings
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration or domain services, not direct DbContext queries
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

### [Critical] Review aggregate mutates Catalog aggregate (Product.UpdateReviewStats) synchronously
- **Issue:** After creating/updating/deleting a review, handlers directly load Product from CatalogDbContext and call product.UpdateReviewStats(), causing synchronous cross-context writes
- **Principle:** Aggregates in different bounded contexts should not be mutated in the same transaction; use domain events for eventual consistency
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Warning] Review.UserId and Review.ProductId are Guid, not strongly-typed IDs
- **Issue:** Review stores `Guid UserId` and `Guid ProductId` instead of strongly-typed value objects, breaking consistency
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** Strongly-typed IDs best practices

### [Info] GetReviewsByProductQuery performs batch N+1 prevention
- **Issue:** Query correctly performs batch lookups (ProfilesDbContext for display names, OrderingDbContext for purchase verification), but this cross-context access pattern is repeated across multiple handlers
- **Principle:** Cross-context queries indicate potential for a read model or anti-corruption layer
- **Reference:** CQRS read model patterns

### [Critical] CreateReviewCommand returns Guid (creation ID), which is correct for CQRS
- **Issue:** This is NOT an issue - CreateReviewCommand correctly returns Guid (the review ID) per CQRS pattern
- **Principle:** CQRS commands for creation can return the entity ID for client navigation
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

## Wishlists Module

### [Critical] WishlistItem is modeled as entity but has no aggregate root
- **Issue:** WishlistItem is a standalone entity with identity (WishlistItemId) but does not inherit from BaseAggregateRoot or have domain events, yet it's treated as a top-level entity
- **Principle:** Entities with lifecycle and business rules should be aggregate roots or owned by an aggregate root
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] WishlistItem lacks domain behavior
- **Issue:** WishlistItem is an anemic entity with only data properties and a factory method, no business rules or invariants
- **Principle:** Entities should encapsulate business logic; anemic entities push behavior into services (anemic domain model anti-pattern)
- **Reference:** [Anemic Domain Model - Martin Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html)

### [Critical] GetUserWishlistQuery injects multiple DbContexts (cross-context access)
- **Issue:** GetUserWishlistQueryHandler injects WishlistsDbContext, CatalogDbContext, and InventoryDbContext to batch-load product and stock data
- **Principle:** Bounded contexts should be isolated; cross-context queries indicate need for a read model or materialized view
- **Reference:** CQRS read model patterns, [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

### [Warning] WishlistItem.UserId and WishlistItem.ProductId are Guid, not strongly-typed IDs
- **Issue:** WishlistItem stores `Guid UserId` and `Guid ProductId` instead of strongly-typed value objects, breaking consistency
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** Strongly-typed IDs best practices

### [Info] AddToWishlistCommand returns Guid (creation ID), which is correct for CQRS
- **Issue:** This is NOT an issue - AddToWishlistCommand correctly returns Guid (the wishlist item ID) per CQRS pattern
- **Principle:** CQRS commands for creation can return the entity ID for idempotency checks
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)
