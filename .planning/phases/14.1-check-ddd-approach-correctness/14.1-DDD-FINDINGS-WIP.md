# DDD Audit Findings (Work in Progress)

## BuildingBlocks/Common Foundation

### [Warning] Missing Base Entity class for child entities
- **Issue:** No `Entity<TId>` base class exists for child entities like OrderItem and CartItem. Child entities must implement identity management manually without framework support.
- **Principle:** Entity base classes should provide common identity, equality, and lifecycle behavior for non-aggregate entities (Vernon's Aggregate Design)
- **Reference:** [Microsoft Learn - Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### [Info] DomainEvent.DateOccurred has protected setter
- **Issue:** DomainEvent base class has `DateOccurred` property with a protected setter, allowing derived events to mutate the timestamp after creation
- **Principle:** Domain events should be immutable once created
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Info] BaseAggregateRoot.Id uses init instead of protected init
- **Issue:** The `Id` property uses `init` accessor, allowing initialization from outside the aggregate hierarchy (though primary constructor enforces it)
- **Principle:** Aggregate identity should be fully encapsulated and only settable during construction
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Info] ValueObject caches hash code, which can break mutability guarantees
- **Issue:** ValueObject base class caches hash code in `_cachedHashCode` field, which is an optimization that assumes immutability but doesn't enforce it
- **Principle:** Value objects should be immutable by design, but the implementation relies on convention rather than enforcement
- **Reference:** [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

### [Warning] Obsolete domain event dispatcher infrastructure still present
- **Issue:** The codebase contains obsolete MediatorDomainEventDispatcher, IDomainEventDispatcher, and IDomainEventHandler marked with [Obsolete], but these are still part of the BuildingBlocks API surface
- **Principle:** Dead code should be removed to prevent confusion and accidental usage
- **Reference:** Clean Code principles - remove obsolete infrastructure after migration

## Catalog Module

### [Critical] Product aggregate holds navigation property to Category aggregate
- **Issue:** Product entity has `public Category? Category { get; private set; }` navigation property, creating an object reference to another aggregate root
- **Principle:** Vernon's Rule 3 - Aggregates should reference other aggregates by identity only, not object references
- **Reference:** [Aggregate Design Rules according to Vaughn Vernon](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)

### [Warning] Category not raising domain event on Update
- **Issue:** Category.Update() method changes Name and Description but does not raise a CategoryUpdatedDomainEvent (only CategoryCreatedDomainEvent exists)
- **Principle:** All significant state changes in aggregates should raise domain events to enable eventual consistency and event-driven patterns
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Info] Category has redundant behavior methods
- **Issue:** Category has three update methods: Update(), UpdateName(), and UpdateDescription(), where the latter two are unused granular alternatives to Update()
- **Principle:** Behavior methods should align with actual use cases (YAGNI principle)
- **Reference:** Clean Architecture - avoid speculative generality

### [Warning] ProductStatus is enum, not value object
- **Issue:** ProductStatus is a simple enum rather than a value object with behavior
- **Principle:** Domain concepts with validation rules or behavior should be value objects, not primitive enums
- **Reference:** [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)

### [Critical] UpdateProductCommandHandler returns bool instead of void
- **Issue:** UpdateProductCommandHandler returns `bool` (always true) rather than `void` or `Unit`
- **Principle:** CQRS commands should return void or minimal data (ID only for creation), not success flags
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

### [Warning] Cross-context category existence check in CreateProductCommandHandler
- **Issue:** CreateProductCommandHandler validates CategoryId existence by querying CatalogDbContext.Categories, which is within the same context but represents potential future bounded context boundary violation
- **Principle:** If Category and Product were separate bounded contexts, this check would violate context isolation
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

### [Info] Product.UpdateReviewStats bypasses invariant protection
- **Issue:** Product.UpdateReviewStats() is a public method called by external event handlers (Reviews context), directly mutating denormalized statistics without business rules
- **Principle:** Public aggregate methods should enforce invariants; data synchronization methods could be internal or use a different pattern
- **Reference:** [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### [Warning] Money value object uses class inheritance instead of record struct
- **Issue:** Money is implemented as a sealed class inheriting from ValueObject abstract class, rather than using a readonly record struct (as recommended in ValueObject.cs comments)
- **Principle:** Modern C# (10+) recommends readonly record structs for value objects (immutability by default, structural equality, no heap allocation)
- **Reference:** [Using C# 9 records as strongly-typed ids - Thomas Levesque](https://thomaslevesque.com/2020/10/30/using-csharp-9-records-as-strongly-typed-ids/)

### [Info] ProductName has implicit string conversion operator
- **Issue:** ProductName provides `public static implicit operator string(ProductName name)` for convenience, which can bypass domain logic
- **Principle:** Implicit conversions reduce type safety and can lead to primitive obsession leakage
- **Reference:** Domain-driven design best practices - prefer explicit over implicit conversions

### [Info] Product.Description is plain string, not value object
- **Issue:** Product.Description is a primitive string with no validation or constraints, despite being a domain concept
- **Principle:** Primitive obsession - domain concepts should be modeled as value objects when they have validation rules
- **Reference:** [DDD Anti-patterns - Primitive Obsession](https://alok-mishra.com/2021/11/03/ddd-anti-patterns/)

## Ordering Module

### [Critical] OrderItem has public factory method but no aggregate root protection
- **Issue:** OrderItem.Create() is a public static factory method, allowing OrderItem entities to be created outside the Order aggregate
- **Principle:** Child entities should only be created and managed through their aggregate root to enforce invariants
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] ShippingAddress is a record but does not inherit from ValueObject base class
- **Issue:** ShippingAddress is implemented as a `record` with manual validation, bypassing the ValueObject base class pattern used elsewhere
- **Principle:** Inconsistent value object implementation patterns reduce maintainability
- **Reference:** Consistency in tactical DDD patterns across the codebase

### [Warning] OrderStatus is enum, not value object
- **Issue:** OrderStatus is a simple enum (Submitted, StockReserved, Paid, etc.) without behavior or state transition validation
- **Principle:** Status enums with state machine semantics should be value objects or use the State pattern
- **Reference:** [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)

### [Critical] Order.MarkStockReserved() is public but saga-internal
- **Issue:** Order.MarkStockReserved() is a public method intended only for saga internal transitions, exposing internal state machine details
- **Principle:** Aggregate public API should reflect business operations, not orchestration internals
- **Reference:** [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### [Info] Order calculates business rules (tax, shipping) with hardcoded constants
- **Issue:** Order.Create() uses hardcoded `FlatShippingCost = 5.99m` and `TaxRate = 0.08m` as private constants, not domain services or configuration
- **Principle:** Business rules that change should be externalized to domain services or configuration
- **Reference:** DDD Layered Architecture - business rules vs. technical configuration

### [Warning] Order has no domain event for status transitions beyond Submitted/Paid/Failed
- **Issue:** Order.Confirm(), Order.Ship(), and Order.Deliver() do not raise domain events, preventing event-driven subscribers from reacting to order lifecycle
- **Principle:** All significant state changes should raise domain events for consistency and auditability
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### [Critical] ReserveStockForOrderConsumer directly queries and mutates Inventory aggregate from Ordering context
- **Issue:** ReserveStockForOrderConsumer (in Ordering.Application) directly injects InventoryDbContext and calls `stockItem.Reserve()`, crossing bounded context boundaries in-process
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration, not direct DbContext access
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html), [Domain analysis for microservices - Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis)

### [Critical] CheckoutState saga state is not an aggregate root
- **Issue:** CheckoutState implements `SagaStateMachineInstance` (MassTransit) but does not inherit from BaseAggregateRoot or implement IAggregateRoot, lacking domain event infrastructure
- **Principle:** Saga state instances with lifecycle and state transitions are conceptually aggregate roots
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

### [Warning] CheckoutState.ReservationIdsJson stores serialized JSON in saga state
- **Issue:** CheckoutState stores `Dictionary<Guid, Guid>` as serialized JSON string for compensation, mixing persistence concern with saga orchestration
- **Principle:** Saga state should use structured data; JSON serialization is a persistence detail
- **Reference:** MassTransit saga best practices - prefer structured properties over serialized blobs

### [Info] Saga contract events (CheckoutStarted, PaymentCompleted, etc.) are not explicitly modeled
- **Issue:** Saga events are referenced by name in CheckoutStateMachine but defined in Contracts.cs (not read in this audit), unclear if they follow domain event conventions
- **Principle:** Saga event contracts should be treated as explicit domain events with clear schemas
- **Reference:** Event-driven architecture best practices

### [Critical] SubmitOrderCommandHandler returns SubmitOrderResult with OrderNumber, violating CQRS
- **Issue:** SubmitOrderCommandHandler returns `SubmitOrderResult(order.Id.Value, order.OrderNumber.Value)` with both ID and OrderNumber
- **Principle:** CQRS commands should return void or creation ID only, not full result objects
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

### [Warning] Order.BuyerId is Guid, not strongly-typed BuyerId
- **Issue:** Order entity uses `Guid BuyerId` primitive instead of a strongly-typed `BuyerId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)

### [Warning] OrderItem.ProductId is Guid, not strongly-typed ProductId
- **Issue:** OrderItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

### [Info] Order.Items collection uses List<OrderItem> internally, exposing IReadOnlyCollection
- **Issue:** Order uses `private readonly List<OrderItem> _items = []` with `IReadOnlyCollection<OrderItem> Items` public property, which is correct, but OrderItem creation still happens outside the aggregate (see OrderItem.Create issue)
- **Principle:** Collection encapsulation is correct, but enforcement of aggregate boundary is incomplete
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)
