# DDD Tactical Patterns Audit Report

**Date:** 2026-02-14
**Scope:** Full codebase audit — BuildingBlocks/Common + 7 feature modules
**Reference Standard:** Modern .NET DDD (eShopOnContainers, Clean Architecture, Vaughn Vernon's Effective Aggregate Design, MediatR CQRS patterns)

## Executive Summary

This audit identifies **systemic architectural issues** that violate core DDD principles, primarily in **bounded context isolation** and **aggregate design**. The codebase demonstrates strong tactical implementation in some areas (strongly-typed IDs, value objects, domain events) but suffers from critical violations that undermine the benefits of DDD:

**Most Critical Systemic Issues:**

1. **Bounded Context Leakage (Critical)**: Reviews and Wishlists modules directly inject and query OrderingDbContext, CatalogDbContext, and InventoryDbContext within handlers, creating tight in-process coupling. Ordering's ReserveStockForOrderConsumer directly accesses InventoryDbContext. This violates the core DDD principle of bounded context independence and prevents future microservice extraction.

2. **Aggregate Boundary Violations (Critical)**: Child entities (CartItem, OrderItem, StockReservation) have public factory methods, allowing external instantiation outside aggregate control. Address in Profiles is modeled as a ValueObject but has identity (AddressId) and internal mutators, creating identity/immutability confusion.

3. **CQRS Command Return Violations (Warning)**: Multiple commands return non-standard results (AddToCartResult with isUpdate flag, UpdateProductCommandHandler returns bool, SubmitOrderResult returns both ID and OrderNumber), violating the CQRS principle that commands should return void or creation ID only.

4. **Strongly-Typed ID Inconsistency (Warning)**: While the BuildingBlocks/Common provides StronglyTypedId infrastructure and most aggregates use it (ProductId, OrderId, etc.), cross-context references frequently use primitive Guid (Order.BuyerId, OrderItem.ProductId, Cart.BuyerId, StockItem.ProductId, Review.UserId/ProductId, WishlistItem.UserId/ProductId), breaking type safety at module boundaries.

**Pattern Inconsistencies:**

- **v1.0 modules (Catalog, Cart, Ordering, Inventory)** have more mature aggregate designs with domain events, but suffer from cross-context violations.
- **v1.1 modules (Profiles, Reviews, Wishlists)** have cleaner individual implementations but worse bounded context isolation due to cross-cutting read requirements (reviews need purchase verification, wishlists need product/stock data).

**Positive Observations:**

The codebase demonstrates understanding of DDD tactical patterns (strongly-typed IDs, value objects with validation, domain events with MassTransit, optimistic concurrency via xmin, repository pattern via DbContext per module). The issues identified are architectural rather than fundamental misunderstandings.

**Remediation Priority:**

1. **Bounded context isolation** (Critical) — Replace direct DbContext injection with event-driven integration or read models
2. **Aggregate boundary enforcement** (Critical) — Make child entity factories internal/private, resolve Address identity confusion
3. **CQRS command returns** (Warning) — Standardize command returns across modules
4. **Strongly-typed ID consistency** (Warning) — Apply strongly-typed IDs to all cross-context references

---

## Cross-Cutting Findings

### Bounded Context Isolation

**[Critical] Direct cross-context DbContext injection in Reviews module**
- **Issue:** CreateReviewCommandHandler, UpdateReviewCommandHandler, DeleteReviewCommandHandler inject OrderingDbContext (purchase verification) and CatalogDbContext (product rating updates). Handlers directly query Orders table and mutate Product entity within the same handler transaction.
- **Principle:** Bounded contexts must maintain isolation; cross-context operations should use domain events or integration events, not direct database queries
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html), [Domain analysis for microservices - Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis)
- **Impact:** Reviews cannot be extracted to a separate service without major refactoring

**[Critical] Direct cross-context DbContext injection in Wishlists module**
- **Issue:** GetUserWishlistQueryHandler injects WishlistsDbContext, CatalogDbContext, and InventoryDbContext to perform batch N+1 prevention for product and stock data
- **Principle:** Queries crossing bounded contexts should use read models or materialized views, not direct DbContext queries
- **Reference:** CQRS read model patterns, [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)
- **Impact:** Wishlists cannot be extracted without creating a dedicated read model or API gateway aggregation

**[Critical] Ordering consumer directly mutates Inventory aggregate**
- **Issue:** ReserveStockForOrderConsumer (in Ordering.Application.Consumers) directly injects InventoryDbContext and calls `stockItem.Reserve()`, crossing bounded context boundaries in-process
- **Principle:** Sagas/consumers should coordinate via events, not directly manipulate aggregates in other contexts
- **Reference:** [Saga Pattern](https://microservices.io/patterns/data/saga.html), MassTransit saga best practices
- **Impact:** Inventory and Ordering are tightly coupled; true microservice deployment would require event-driven reservation protocol

**[Warning] Cross-context category existence check in Catalog**
- **Issue:** CreateProductCommandHandler validates CategoryId existence by querying CatalogDbContext.Categories. While both are in the same context now, this pattern represents potential future bounded context boundary violation if Category were to become a separate context
- **Principle:** Design for potential context boundaries even within modular monoliths
- **Reference:** [Modular Monolith](https://www.kamilgrzybek.com/blog/posts/modular-monolith-primer)
- **Impact:** Low immediate risk, but indicates lack of clear context boundaries

**[Info] Product aggregate has navigation property to Category aggregate**
- **Issue:** Product entity has `public Category? Category { get; private set; }` navigation property, creating an object reference to another aggregate root
- **Principle:** Vernon's Rule 3 - Aggregates should reference other aggregates by identity only, not object references (though EF Core may require navigation properties for lazy loading)
- **Reference:** [Aggregate Design Rules according to Vaughn Vernon](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)
- **Impact:** Acceptable in modular monoliths with careful usage; problematic for microservice extraction

### CQRS Patterns

**[Critical] AddToCartCommand returns AddToCartResult with business logic flag**
- **Issue:** AddToCartCommandHandler returns `AddToCartResult(isUpdate)` with a flag indicating whether the operation was an update vs. create
- **Principle:** CQRS commands should return void or creation ID only, not result objects with business state
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)
- **Impact:** Client receives business logic in command response, blurring command-query separation

**[Critical] UpdateProductCommandHandler returns bool**
- **Issue:** UpdateProductCommandHandler returns `bool` (always true) rather than `void` or `Unit`
- **Principle:** CQRS commands should return void or minimal data (ID only for creation), not success flags
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)
- **Impact:** Similar pattern in UpdateCategoryCommandHandler and ChangeProductStatusCommandHandler

**[Critical] SubmitOrderCommandHandler returns SubmitOrderResult with OrderNumber**
- **Issue:** SubmitOrderCommandHandler returns `SubmitOrderResult(order.Id.Value, order.OrderNumber.Value)` with both ID and OrderNumber
- **Principle:** CQRS commands should return void or creation ID only, not full result objects
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)
- **Impact:** Acceptable for creation commands to return ID, but OrderNumber is a business value that should be queried separately

**[Info] Creation commands correctly return Guid for entity ID**
- **Issue:** This is NOT an issue — CreateReviewCommand, AddToWishlistCommand, CreateProductCommand, CreateCategoryCommand correctly return Guid (entity ID) per CQRS pattern
- **Principle:** CQRS commands for creation can return the entity ID for client navigation and idempotency
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

**[Info] Queries are read-only and use AsNoTracking**
- **Issue:** This is NOT an issue — Query handlers correctly use `AsNoTracking()` and do not call SaveChangesAsync
- **Principle:** CQRS queries should be read-only and not modify state
- **Reference:** CQRS patterns

### Ubiquitous Language

**[Info] Infrastructure services use generic "-Service" suffix**
- **Issue:** CartExpirationService, AvatarImageService, ImageUploadService, ReservationCleanupService use generic "Service" suffix rather than domain-specific names
- **Principle:** Ubiquitous language should extend to infrastructure; domain-specific names are preferred (e.g., "CartExpirationJob" or "ExpiredCartPurger")
- **Reference:** [Ubiquitous Language - DDD](https://martinfowler.com/bliki/UbiquitousLanguage.html)
- **Impact:** Minor — these are infrastructure concerns (BackgroundService implementations), not domain services

**[Info] BuyerIdentity is a static utility outside domain model**
- **Issue:** BuyerIdentity.GetOrCreateBuyerId() is a static utility mixing infrastructure concerns (cookies, claims) with domain logic (buyer identity)
- **Principle:** Domain concepts should be modeled explicitly; buyer identity resolution could be a domain service with explicit naming
- **Reference:** DDD Layered Architecture - domain services vs. infrastructure utilities
- **Impact:** BuyerIdentity is a cross-cutting concern for guest/authenticated users; acceptable as infrastructure utility but could be renamed (e.g., BuyerIdentityResolver)

**[Info] Consistent domain term usage across modules**
- **Issue:** This is NOT an issue — Domain terms (Product, Order, Cart, Review, Wishlist, StockItem, UserProfile) are used consistently. OrderStatus, ProductStatus use standard e-commerce vocabulary.
- **Principle:** Ubiquitous language should be consistent across the bounded context
- **Reference:** [Ubiquitous Language - DDD](https://martinfowler.com/bliki/UbiquitousLanguage.html)

### Pattern Consistency

**[Warning] v1.1 modules lack domain events (Wishlists)**
- **Issue:** WishlistItem does not raise domain events for add/remove operations, unlike v1.0 modules (Product, Order, StockItem, Review)
- **Principle:** All significant state changes should raise domain events for eventual consistency and auditability
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)
- **Impact:** Inconsistent event-driven integration; Wishlist additions/removals cannot trigger downstream reactions

**[Warning] Strongly-typed IDs inconsistently applied to cross-context references**
- **Issue:** BuildingBlocks/Common provides StronglyTypedId infrastructure, but cross-context references use primitive Guid (Order.BuyerId, OrderItem.ProductId, Cart.BuyerId, StockItem.ProductId, Review.UserId/ProductId, WishlistItem.UserId/ProductId)
- **Principle:** All entity references should use strongly-typed IDs for type safety and consistency
- **Reference:** [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)
- **Impact:** Reduced type safety at module boundaries; no compiler enforcement of correct ID types

**[Info] ShippingAddress uses record, not ValueObject base class**
- **Issue:** ShippingAddress (in Ordering) is implemented as a `record` with manual validation, bypassing the ValueObject base class pattern used elsewhere (ProductName, Money, DisplayName, Rating, ReviewText)
- **Principle:** Inconsistent value object implementation patterns reduce maintainability
- **Reference:** Consistency in tactical DDD patterns across the codebase
- **Impact:** Minor — record is acceptable for value objects, but inconsistency makes pattern recognition harder

---

## Module Findings

### BuildingBlocks/Common Foundation

**[Warning] Missing Base Entity class for child entities**
- **Issue:** No `Entity<TId>` base class exists for child entities like OrderItem and CartItem. Child entities must implement identity management manually without framework support.
- **Principle:** Entity base classes should provide common identity, equality, and lifecycle behavior for non-aggregate entities (Vernon's Aggregate Design)
- **Reference:** [Microsoft Learn - Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

**[Info] DomainEvent.DateOccurred has protected setter**
- **Issue:** DomainEvent base class has `DateOccurred` property with a protected setter, allowing derived events to mutate the timestamp after creation
- **Principle:** Domain events should be immutable once created
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

**[Info] BaseAggregateRoot.Id uses init instead of protected init**
- **Issue:** The `Id` property uses `init` accessor, allowing initialization from outside the aggregate hierarchy (though primary constructor enforces it)
- **Principle:** Aggregate identity should be fully encapsulated and only settable during construction
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

**[Info] ValueObject caches hash code, which can break mutability guarantees**
- **Issue:** ValueObject base class caches hash code in `_cachedHashCode` field, which is an optimization that assumes immutability but doesn't enforce it
- **Principle:** Value objects should be immutable by design, but the implementation relies on convention rather than enforcement
- **Reference:** [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

**[Warning] Obsolete domain event dispatcher infrastructure still present**
- **Issue:** The codebase contains obsolete MediatorDomainEventDispatcher, IDomainEventDispatcher, and IDomainEventHandler marked with [Obsolete], but these are still part of the BuildingBlocks API surface
- **Principle:** Dead code should be removed to prevent confusion and accidental usage
- **Reference:** Clean Code principles - remove obsolete infrastructure after migration

---

### Catalog Module

**[Critical] Product aggregate holds navigation property to Category aggregate**
- **Issue:** Product entity has `public Category? Category { get; private set; }` navigation property, creating an object reference to another aggregate root
- **Principle:** Vernon's Rule 3 - Aggregates should reference other aggregates by identity only, not object references
- **Reference:** [Aggregate Design Rules according to Vaughn Vernon](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)

**[Warning] Category not raising domain event on Update**
- **Issue:** Category.Update() method changes Name and Description but does not raise a CategoryUpdatedDomainEvent (only CategoryCreatedDomainEvent exists)
- **Principle:** All significant state changes in aggregates should raise domain events to enable eventual consistency and event-driven patterns
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

**[Info] Category has redundant behavior methods**
- **Issue:** Category has three update methods: Update(), UpdateName(), and UpdateDescription(), where the latter two are unused granular alternatives to Update()
- **Principle:** Behavior methods should align with actual use cases (YAGNI principle)
- **Reference:** Clean Architecture - avoid speculative generality

**[Warning] ProductStatus is enum, not value object**
- **Issue:** ProductStatus is a simple enum rather than a value object with behavior
- **Principle:** Domain concepts with validation rules or behavior should be value objects, not primitive enums
- **Reference:** [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)

**[Critical] UpdateProductCommandHandler returns bool instead of void**
- **Issue:** UpdateProductCommandHandler returns `bool` (always true) rather than `void` or `Unit`
- **Principle:** CQRS commands should return void or minimal data (ID only for creation), not success flags
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

**[Warning] Cross-context category existence check in CreateProductCommandHandler**
- **Issue:** CreateProductCommandHandler validates CategoryId existence by querying CatalogDbContext.Categories, which is within the same context but represents potential future bounded context boundary violation
- **Principle:** If Category and Product were separate bounded contexts, this check would violate context isolation
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

**[Info] Product.UpdateReviewStats bypasses invariant protection**
- **Issue:** Product.UpdateReviewStats() is a public method called by external event handlers (Reviews context), directly mutating denormalized statistics without business rules
- **Principle:** Public aggregate methods should enforce invariants; data synchronization methods could be internal or use a different pattern
- **Reference:** [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

**[Warning] Money value object uses class inheritance instead of record struct**
- **Issue:** Money is implemented as a sealed class inheriting from ValueObject abstract class, rather than using a readonly record struct (as recommended in ValueObject.cs comments)
- **Principle:** Modern C# (10+) recommends readonly record structs for value objects (immutability by default, structural equality, no heap allocation)
- **Reference:** [Using C# 9 records as strongly-typed ids - Thomas Levesque](https://thomaslevesque.com/2020/10/30/using-csharp-9-records-as-strongly-typed-ids/)

**[Info] ProductName has implicit string conversion operator**
- **Issue:** ProductName provides `public static implicit operator string(ProductName name)` for convenience, which can bypass domain logic
- **Principle:** Implicit conversions reduce type safety and can lead to primitive obsession leakage
- **Reference:** Domain-driven design best practices - prefer explicit over implicit conversions

**[Info] Product.Description is plain string, not value object**
- **Issue:** Product.Description is a primitive string with no validation or constraints, despite being a domain concept
- **Principle:** Primitive obsession - domain concepts should be modeled as value objects when they have validation rules
- **Reference:** [DDD Anti-patterns - Primitive Obsession](https://alok-mishra.com/2021/11/03/ddd-anti-patterns/)

---

### Ordering Module

**[Critical] OrderItem has public factory method but no aggregate root protection**
- **Issue:** OrderItem.Create() is a public static factory method, allowing OrderItem entities to be created outside the Order aggregate
- **Principle:** Child entities should only be created and managed through their aggregate root to enforce invariants
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

**[Warning] ShippingAddress is a record but does not inherit from ValueObject base class**
- **Issue:** ShippingAddress is implemented as a `record` with manual validation, bypassing the ValueObject base class pattern used elsewhere
- **Principle:** Inconsistent value object implementation patterns reduce maintainability
- **Reference:** Consistency in tactical DDD patterns across the codebase

**[Warning] OrderStatus is enum, not value object**
- **Issue:** OrderStatus is a simple enum (Submitted, StockReserved, Paid, etc.) without behavior or state transition validation
- **Principle:** Status enums with state machine semantics should be value objects or use the State pattern
- **Reference:** [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)

**[Critical] Order.MarkStockReserved() is public but saga-internal**
- **Issue:** Order.MarkStockReserved() is a public method intended only for saga internal transitions, exposing internal state machine details
- **Principle:** Aggregate public API should reflect business operations, not orchestration internals
- **Reference:** [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

**[Info] Order calculates business rules (tax, shipping) with hardcoded constants**
- **Issue:** Order.Create() uses hardcoded `FlatShippingCost = 5.99m` and `TaxRate = 0.08m` as private constants, not domain services or configuration
- **Principle:** Business rules that change should be externalized to domain services or configuration
- **Reference:** DDD Layered Architecture - business rules vs. technical configuration

**[Warning] Order has no domain event for status transitions beyond Submitted/Paid/Failed**
- **Issue:** Order.Confirm(), Order.Ship(), and Order.Deliver() do not raise domain events, preventing event-driven subscribers from reacting to order lifecycle
- **Principle:** All significant state changes should raise domain events for consistency and auditability
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

**[Critical] ReserveStockForOrderConsumer directly queries and mutates Inventory aggregate from Ordering context**
- **Issue:** ReserveStockForOrderConsumer (in Ordering.Application) directly injects InventoryDbContext and calls `stockItem.Reserve()`, crossing bounded context boundaries in-process
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration, not direct DbContext access
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html), [Domain analysis for microservices - Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis)

**[Critical] CheckoutState saga state is not an aggregate root**
- **Issue:** CheckoutState implements `SagaStateMachineInstance` (MassTransit) but does not inherit from BaseAggregateRoot or implement IAggregateRoot, lacking domain event infrastructure
- **Principle:** Saga state instances with lifecycle and state transitions are conceptually aggregate roots
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

**[Warning] CheckoutState.ReservationIdsJson stores serialized JSON in saga state**
- **Issue:** CheckoutState stores `Dictionary<Guid, Guid>` as serialized JSON string for compensation, mixing persistence concern with saga orchestration
- **Principle:** Saga state should use structured data; JSON serialization is a persistence detail
- **Reference:** MassTransit saga best practices - prefer structured properties over serialized blobs

**[Info] Saga contract events (CheckoutStarted, PaymentCompleted, etc.) are not explicitly modeled**
- **Issue:** Saga events are referenced by name in CheckoutStateMachine but defined in Contracts.cs (not read in this audit), unclear if they follow domain event conventions
- **Principle:** Saga event contracts should be treated as explicit domain events with clear schemas
- **Reference:** Event-driven architecture best practices

**[Critical] SubmitOrderCommandHandler returns SubmitOrderResult with OrderNumber, violating CQRS**
- **Issue:** SubmitOrderCommandHandler returns `SubmitOrderResult(order.Id.Value, order.OrderNumber.Value)` with both ID and OrderNumber
- **Principle:** CQRS commands should return void or creation ID only, not full result objects
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

**[Warning] Order.BuyerId is Guid, not strongly-typed BuyerId**
- **Issue:** Order entity uses `Guid BuyerId` primitive instead of a strongly-typed `BuyerId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)

**[Warning] OrderItem.ProductId is Guid, not strongly-typed ProductId**
- **Issue:** OrderItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

**[Info] Order.Items collection uses List<OrderItem> internally, exposing IReadOnlyCollection**
- **Issue:** Order uses `private readonly List<OrderItem> _items = []` with `IReadOnlyCollection<OrderItem> Items` public property, which is correct, but OrderItem creation still happens outside the aggregate (see OrderItem.Create issue)
- **Principle:** Collection encapsulation is correct, but enforcement of aggregate boundary is incomplete
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

---

### Cart Module

**[Critical] CartItem has public factory method but no aggregate root protection**
- **Issue:** CartItem.Create() is a public static factory method, allowing CartItem entities to be created outside the Cart aggregate
- **Principle:** Child entities should only be created and managed through their aggregate root to enforce invariants (Vernon's Rule 1)
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

**[Warning] Cart.BuyerId is Guid, not strongly-typed BuyerId**
- **Issue:** Cart entity uses `Guid BuyerId` primitive instead of a strongly-typed `BuyerId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety and consistency
- **Reference:** [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)

**[Warning] CartItem.ProductId is Guid, not strongly-typed ProductId**
- **Issue:** CartItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

**[Warning] Cart does not raise domain events**
- **Issue:** Cart aggregate does not raise any domain events for significant operations (item added, item removed, cart transferred)
- **Principle:** All significant state changes should raise domain events for eventual consistency and event-driven patterns
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

**[Info] BuyerIdentity is a static utility class outside domain model**
- **Issue:** BuyerIdentity.GetOrCreateBuyerId() is a static utility that mixes infrastructure concerns (cookies, claims) with domain logic (buyer identity)
- **Principle:** Domain concepts should be modeled explicitly; buyer identity resolution could be a domain service
- **Reference:** DDD Layered Architecture - domain services vs. infrastructure utilities

**[Critical] AddToCartCommand returns AddToCartResult with isUpdate flag**
- **Issue:** AddToCartCommandHandler returns `AddToCartResult(isUpdate)` with business logic flag, violating CQRS command-query separation
- **Principle:** CQRS commands should return void or creation ID only, not result objects with business state
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

---

### Inventory Module

**[Warning] StockAdjustment is separate entity, not managed by StockItem aggregate**
- **Issue:** StockAdjustment is created independently (likely in handlers), not through StockItem aggregate methods, creating a separate audit trail disconnected from the aggregate
- **Principle:** Related entities in the same consistency boundary should be managed through the aggregate root
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

**[Warning] StockReservation has public factory method but is owned by StockItem**
- **Issue:** StockReservation.Create() is a public static factory method, but the entity is owned by StockItem aggregate and created within StockItem.Reserve()
- **Principle:** Child entity factories should be internal or private to prevent external instantiation
- **Reference:** Aggregate boundary enforcement

**[Info] StockItem.AvailableQuantity is a calculated property, not a value object**
- **Issue:** AvailableQuantity is a computed property (`QuantityOnHand - active reservations`) without explicit value object modeling
- **Principle:** Domain calculations can be value objects or domain services for richer modeling
- **Reference:** DDD tactical patterns

**[Warning] StockItem.ProductId is Guid, not strongly-typed ProductId**
- **Issue:** StockItem stores `Guid ProductId` instead of `Catalog.Domain.ValueObjects.ProductId`, preventing type-safe cross-context references
- **Principle:** Cross-aggregate references should use strongly-typed IDs from the owning context
- **Reference:** Strongly-typed IDs best practices

**[Critical] ReserveStockForOrderConsumer (in Ordering) directly queries and mutates Inventory aggregate**
- **Issue:** ReserveStockForOrderConsumer (in Ordering.Application) directly injects InventoryDbContext and calls `stockItem.Reserve()`, crossing bounded context boundaries in-process
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration, not direct DbContext access
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

---

### Profiles Module

**[Critical] Address is modeled as ValueObject but has mutable identity (AddressId)**
- **Issue:** Address inherits from ValueObject base class but has an `AddressId` property, mixing entity semantics (identity) with value object semantics (structural equality)
- **Principle:** Value objects are defined by their attributes only, without identity; Address should be an entity if it has identity
- **Reference:** [Value Objects - Martin Fowler](https://martinfowler.com/bliki/ValueObject.html), [Entity vs Value Object - DDD](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)

**[Warning] Address has internal mutators (SetAsDefault, ClearDefault)**
- **Issue:** Address has internal methods SetAsDefault() and ClearDefault() that mutate state, contradicting value object immutability principle
- **Principle:** Value objects should be immutable; mutability indicates entity semantics
- **Reference:** [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

**[Info] UserProfile.UpdateAddress replaces address instead of mutating**
- **Issue:** UserProfile.UpdateAddress() removes the old address and adds a new one, preserving immutability, but this is inconsistent with Address having an identity (AddressId)
- **Principle:** If Address is an entity (has identity), it should be mutable; if it's a value object, it shouldn't have AddressId
- **Reference:** Entity vs Value Object distinction

**[Warning] UserProfile.UserId is Guid, not strongly-typed UserId**
- **Issue:** UserProfile stores `Guid UserId` instead of a strongly-typed `UserId` value object, breaking the strongly-typed ID pattern used elsewhere
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** Strongly-typed IDs best practices

**[Info] UserProfile does not enforce address limit**
- **Issue:** UserProfile allows unlimited addresses with no business rule enforcement (e.g., max 5 addresses)
- **Principle:** Aggregates enforce business invariants; if there's a domain rule, it should be in the aggregate
- **Reference:** Aggregate invariant enforcement

---

### Reviews Module

**[Critical] Review handlers inject multiple DbContexts (cross-context access)**
- **Issue:** CreateReviewCommandHandler, UpdateReviewCommandHandler, and DeleteReviewCommandHandler inject OrderingDbContext and CatalogDbContext to verify purchases and update product ratings
- **Principle:** Bounded contexts should be isolated; cross-context operations should use event-driven integration or domain services, not direct DbContext queries
- **Reference:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

**[Critical] Review aggregate mutates Catalog aggregate (Product.UpdateReviewStats) synchronously**
- **Issue:** After creating/updating/deleting a review, handlers directly load Product from CatalogDbContext and call product.UpdateReviewStats(), causing synchronous cross-context writes
- **Principle:** Aggregates in different bounded contexts should not be mutated in the same transaction; use domain events for eventual consistency
- **Reference:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

**[Warning] Review.UserId and Review.ProductId are Guid, not strongly-typed IDs**
- **Issue:** Review stores `Guid UserId` and `Guid ProductId` instead of strongly-typed value objects, breaking consistency
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** Strongly-typed IDs best practices

**[Info] GetReviewsByProductQuery performs batch N+1 prevention**
- **Issue:** Query correctly performs batch lookups (ProfilesDbContext for display names, OrderingDbContext for purchase verification), but this cross-context access pattern is repeated across multiple handlers
- **Principle:** Cross-context queries indicate potential for a read model or anti-corruption layer
- **Reference:** CQRS read model patterns

**[Info] CreateReviewCommand returns Guid (creation ID), which is correct for CQRS**
- **Issue:** This is NOT an issue - CreateReviewCommand correctly returns Guid (the review ID) per CQRS pattern
- **Principle:** CQRS commands for creation can return the entity ID for client navigation
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

---

### Wishlists Module

**[Critical] WishlistItem is modeled as entity but has no aggregate root**
- **Issue:** WishlistItem is a standalone entity with identity (WishlistItemId) but does not inherit from BaseAggregateRoot or have domain events, yet it's treated as a top-level entity
- **Principle:** Entities with lifecycle and business rules should be aggregate roots or owned by an aggregate root
- **Reference:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)

**[Warning] WishlistItem lacks domain behavior**
- **Issue:** WishlistItem is an anemic entity with only data properties and a factory method, no business rules or invariants
- **Principle:** Entities should encapsulate business logic; anemic entities push behavior into services (anemic domain model anti-pattern)
- **Reference:** [Anemic Domain Model - Martin Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html)

**[Critical] GetUserWishlistQuery injects multiple DbContexts (cross-context access)**
- **Issue:** GetUserWishlistQueryHandler injects WishlistsDbContext, CatalogDbContext, and InventoryDbContext to batch-load product and stock data
- **Principle:** Bounded contexts should be isolated; cross-context queries indicate need for a read model or materialized view
- **Reference:** CQRS read model patterns, [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)

**[Warning] WishlistItem.UserId and WishlistItem.ProductId are Guid, not strongly-typed IDs**
- **Issue:** WishlistItem stores `Guid UserId` and `Guid ProductId` instead of strongly-typed value objects, breaking consistency
- **Principle:** All entity references should use strongly-typed IDs for type safety
- **Reference:** Strongly-typed IDs best practices

**[Info] AddToWishlistCommand returns Guid (creation ID), which is correct for CQRS**
- **Issue:** This is NOT an issue - AddToWishlistCommand correctly returns Guid (the wishlist item ID) per CQRS pattern
- **Principle:** CQRS commands for creation can return the entity ID for idempotency checks
- **Reference:** [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

---

## References

1. [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)
2. [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/)
3. [Aggregate Design Rules according to Vaughn Vernon](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)
4. [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)
5. [Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)
6. [Using tactical DDD to design microservices - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)
7. [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)
8. [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)
9. [Value Objects - Martin Fowler](https://martinfowler.com/bliki/ValueObject.html)
10. [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)
11. [Entity vs Value Object - DDD](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)
12. [Anemic Domain Model - Martin Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html)
13. [DDD Anti-patterns - Primitive Obsession](https://alok-mishra.com/2021/11/03/ddd-anti-patterns/)
14. [Domain analysis for microservices - Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis)
15. [Modular Monolith Primer - Kamil Grzybek](https://www.kamilgrzybek.com/blog/posts/modular-monolith-primer)
16. [Saga Pattern - Microservices.io](https://microservices.io/patterns/data/saga.html)
17. [Ubiquitous Language - DDD](https://martinfowler.com/bliki/UbiquitousLanguage.html)
18. [Using C# 9 records as strongly-typed ids - Thomas Levesque](https://thomaslevesque.com/2020/10/30/using-csharp-9-records-as-strongly-typed-ids/)
