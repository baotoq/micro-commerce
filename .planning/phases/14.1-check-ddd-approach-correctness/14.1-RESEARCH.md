# Phase 14.1: Check DDD Approach Correctness - Research

**Researched:** 2026-02-14
**Domain:** Domain-Driven Design tactical patterns audit and validation
**Confidence:** HIGH

## Summary

This phase requires a comprehensive audit of DDD tactical patterns implementation across the entire MicroCommerce codebase. The audit will cover both the foundational BuildingBlocks/Common layer (base classes like AggregateRoot, Entity, ValueObject, StronglyTypedId) and how all seven feature modules (Catalog, Cart, Ordering, Inventory, Profiles, Reviews, Wishlists) apply these patterns in practice.

The codebase follows a vertical slice architecture with CQRS via MediatR, database-per-feature isolation with separate DbContexts, event-driven patterns using MassTransit, and strongly-typed IDs. The reference standard is modern .NET DDD practices from eShopOnContainers, Clean Architecture, and community patterns rather than strict Evans/Vernon orthodoxy.

**Primary recommendation:** Use a systematic audit checklist covering all DDD tactical patterns, organized by feature module, with findings categorized by severity (Critical, Warning, Info) and linked to specific DDD principles from authoritative sources. Focus exclusively on violations and issues, not things done well.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Audit Scope:**
- Full audit of ALL DDD tactical patterns: aggregates, entities, value objects, domain events, repositories, bounded contexts, strongly-typed IDs
- Audit covers both the BuildingBlocks/Common layer (base classes like AggregateRoot, Entity, ValueObject, StronglyTypedId) AND how each feature module uses them
- All 7 feature modules audited with equal scrutiny: Catalog, Cart, Ordering, Inventory, Profiles, Reviews, Wishlists
- Bounded context isolation included — check for cross-context queries, shared models, domain knowledge leaking between feature modules
- CQRS patterns included — validate command/query separation, handler responsibilities, whether commands mutate through aggregates properly

**Correctness Standard:**
- Compare against modern .NET DDD references (eShopOnContainers, Clean Architecture, MediatR patterns)
- Check both structural/behavioral correctness AND naming/ubiquitous language consistency
- Flag deviations from established .NET community DDD best practices

**Action on Findings:**
- Document only — this phase produces a findings report, no code fixes
- Findings grouped by module, each tagged with severity: Critical (breaks DDD invariants), Warning (deviates from best practice), Info (could be improved)
- Describe the issue and the DDD principle violated — no before/after code examples
- Focus on issues only — do not document things done well

**Review Deliverable:**
- Structured markdown report in the phase directory: `.planning/phases/14.1-check-ddd-approach-correctness/`
- Executive summary with key findings but no numeric scoring
- Each finding cites the DDD principle or reference material (books, articles) that supports it

### Claude's Discretion
- Internal organization of the report beyond the module + severity structure
- Order of modules reviewed
- How deep to go on each module based on complexity found

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

## Standard Stack

### Core DDD Audit Framework
| Component | Version/Source | Purpose | Why Standard |
|---------|---------|---------|--------------|
| BuildingBlocks.Common | .NET 10 | Base classes for DDD primitives (AggregateRoot, ValueObject, StronglyTypedId) | Foundation for all domain models across feature modules |
| MediatR | Latest for .NET 10 | CQRS implementation | Industry standard for command/query separation in .NET |
| Entity Framework Core | .NET 10 | Persistence layer | Official Microsoft ORM with DDD support (owned entities, value conversions, backing fields) |
| MassTransit | Latest | Domain event publishing and messaging | Standard for event-driven architectures in .NET microservices |

### Reference Standards
| Source | Purpose | Authority |
|--------|---------|-----------|
| eShopOnContainers | .NET microservices DDD reference architecture | Microsoft official sample |
| Vaughn Vernon's Effective Aggregate Design | Aggregate design rules and patterns | DDD community standard (Red Book author) |
| Microsoft DDD Microservices Guide | Tactical DDD patterns in .NET | Microsoft Learn official documentation |
| Enterprise Craftsmanship | Value object implementation patterns | Vladimir Khorikov - .NET DDD expert |

### Supporting Tools
| Tool | Purpose | When to Use |
|------|---------|-------------|
| NDepend | Static analysis for ubiquitous language consistency | Optional - verify naming conventions match domain vocabulary |
| Code review checklist | Systematic pattern validation | Core audit tool |
| Manual code inspection | Deep pattern analysis | All modules - automated tools insufficient for DDD semantics |

**Installation:**
No additional tools required — audit uses existing codebase inspection.

## Architecture Patterns

### Current Codebase Structure
```
src/
  BuildingBlocks/
    BuildingBlocks.Common/          # DDD primitives layer
      BaseAggregateRoot.cs          # Generic aggregate root base class
      ValueObject.cs                # Abstract value object with equality
      StronglyTypedId.cs            # Generic strongly-typed ID base (record)
      Events/                       # Domain event infrastructure
        IDomainEvent.cs             # Marker interface (extends MediatR INotification)
        DomainEvent.cs              # Base domain event class
        IDomainEventDispatcher.cs   # Event dispatcher abstraction
  MicroCommerce.ApiService/
    Features/{Module}/              # Per-feature bounded context
      Domain/
        Entities/                   # Aggregate roots and child entities
        ValueObjects/               # Module-specific value objects
        Events/                     # Domain events
      Application/
        Commands/                   # Write operations (IRequest<T>)
        Queries/                    # Read operations (IRequest<T>)
        Consumers/                  # Event consumers (MassTransit)
      Infrastructure/
        {Module}DbContext.cs        # Owned DbContext (schema isolation)
        Configurations/             # EF Core entity configs
```

### Pattern 1: Aggregate Root Design (Vernon's Rules)

**What:** Aggregates define consistency boundaries, enforce invariants within a single transaction, and publish domain events for cross-aggregate coordination.

**Vaughn Vernon's Four Rules:**
1. **Model True Invariants in Consistency Boundaries** - Only rules requiring transactional consistency belong in the aggregate
2. **Design Small Aggregates** - Prefer minimal aggregates (root + necessary children only) for performance and scalability
3. **Reference Other Aggregates by Identity** - Use IDs, not object references, to prevent cross-aggregate modification
4. **Use Eventual Consistency Outside the Boundary** - Update other aggregates via domain events, not direct mutation

**Audit checklist:**
- Does each aggregate protect true invariants?
- Are aggregates small or do they include unnecessary entity clusters?
- Do aggregates hold object references to other aggregates (anti-pattern)?
- Are cross-aggregate updates handled via domain events?
- Does exactly one entity act as the aggregate root?
- Are all modifications routed through the root?

**Source:** [Effective Aggregate Design by Vaughn Vernon](https://www.dddcommunity.org/library/vernon_2011/), [Aggregate Design Rules](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)

### Pattern 2: Entity vs Value Object Distinction

**What:** Entities have identity and lifecycle; value objects are immutable and compared by value.

**Entity characteristics:**
- Unique identifier (strongly-typed ID in this codebase)
- Mutable state with behavior methods
- Identity persists even if attributes change
- Examples: Product, Order, Cart

**Value Object characteristics:**
- No identifier
- Immutable (C# records or readonly properties)
- Structural equality (compared by all fields)
- Examples: Money, Address, ProductName, Rating

**Audit checklist:**
- Are value objects truly immutable?
- Do value objects override equality correctly?
- Are entities incorrectly modeled as value objects (or vice versa)?
- Do value objects have IDs (anti-pattern)?
- Are value objects mutated instead of replaced (anti-pattern)?

**Source:** [DDD Tactical Patterns - Azure Architecture Center](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd), [Value Object Better Implementation](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

### Pattern 3: Strongly-Typed IDs

**What:** Custom types wrapping primitive IDs (Guid, int) to prevent primitive obsession and provide type safety.

**Modern .NET implementation:**
```csharp
public abstract record StronglyTypedId<T>(T Value);
public record ProductId(Guid Value) : StronglyTypedId<Guid>(Value);
```

**Benefits:**
- Compile-time prevention of mixing entity IDs (can't pass OrderId where ProductId expected)
- Self-documenting code
- Centralized validation and formatting

**Audit checklist:**
- Are all entity IDs strongly-typed?
- Do strongly-typed IDs inherit from a common base?
- Are primitive IDs used in domain layer (anti-pattern)?
- Do strongly-typed IDs provide proper equality and hash code?
- Are strongly-typed IDs serializable for JSON/persistence?

**Source:** [Strongly-typed entity IDs - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/), [Using C# 9 records as strongly-typed ids](https://thomaslevesque.com/2020/10/30/using-csharp-9-records-as-strongly-typed-ids/)

### Pattern 4: Repository Pattern with EF Core

**What:** Repositories abstract data access for aggregate roots only, maintaining a one-to-one relationship with aggregates.

**eShopOnContainers approach:**
- Repository per aggregate root (not per entity)
- Specific repositories, not generic Repository<T>
- DbContext acts as Unit of Work
- EF Core's DbContext already implements Repository + Unit of Work patterns
- Many modern codebases inject DbContext directly into handlers

**Current codebase pattern:**
- DbContext injected directly into MediatR command/query handlers
- No explicit repository abstractions
- SaveChangesAsync called in handlers after aggregate operations

**Audit checklist:**
- Is DbContext accessed only for aggregate roots?
- Are child entities loaded/modified only through their aggregate root?
- Do queries bypass aggregates (acceptable for read-only queries per CQRS)?
- Are commands modifying entities directly without going through aggregate methods?
- Is SaveChangesAsync called after aggregate business methods, not before?

**Source:** [Repository Pattern with EF Core - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-implementation-entity-framework-core), [Is the repository pattern useful with EF Core?](https://www.thereformedprogrammer.net/is-the-repository-pattern-useful-with-entity-framework-core/)

### Pattern 5: Domain Events

**What:** Domain events represent something meaningful that happened in the domain, enabling decoupled communication between aggregates and bounded contexts.

**Key principles:**
- Raised by aggregate roots when state changes
- Published AFTER SaveChangesAsync succeeds (transactional consistency)
- Consumed asynchronously by event handlers
- Enable eventual consistency across aggregates
- MediatR for in-process events, MassTransit for cross-service events

**Audit checklist:**
- Are domain events raised for all significant state changes?
- Are events published after SaveChanges, not before (outbox pattern)?
- Do event names use past tense (ProductCreated, OrderSubmitted)?
- Do events carry necessary data (event ID, aggregate ID, timestamp)?
- Are events handled asynchronously to avoid blocking?
- Do handlers avoid modifying the same aggregate that raised the event?

**Source:** [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation), [Building a Custom Domain Events Dispatcher](https://www.milanjovanovic.tech/blog/building-a-custom-domain-events-dispatcher-in-dotnet)

### Pattern 6: Bounded Context Isolation

**What:** Each feature module represents a bounded context with its own domain model, database schema, and ubiquitous language. Contexts collaborate through contracts, not shared domain models.

**Isolation mechanisms:**
- Separate DbContext per feature (CatalogDbContext, OrderingDbContext, etc.)
- Separate database schemas (catalog, ordering, cart, etc.)
- No direct DbContext cross-references
- Event-driven integration via MassTransit
- Anti-corruption layers for external models

**Audit checklist:**
- Does each feature module have its own DbContext?
- Are DbContexts scoped to a single bounded context?
- Do contexts share domain entities (anti-pattern)?
- Do queries cross context boundaries via DbContext joins (anti-pattern)?
- Are cross-context references by ID only?
- Do event contracts duplicate bounded context models, or share them (anti-pattern)?

**Source:** [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html), [Domain analysis for microservices - Azure](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis), [Bounded Contexts are NOT Microservices](https://vladikk.com/2018/01/21/bounded-contexts-vs-microservices/)

### Pattern 7: CQRS with MediatR

**What:** Separate models for reading (queries) and writing (commands). Commands mutate state via aggregates; queries optimize for read performance.

**Implementation in vertical slices:**
- Commands (IRequest<T>) - validate, load aggregate, call business method, save
- Queries (IRequest<T>) - read-optimized, can bypass aggregates, project to DTOs
- Handlers isolated per use case
- FluentValidation in pipeline behaviors
- Queries may use Dapper or raw SQL for performance

**Audit checklist:**
- Are commands and queries clearly separated?
- Do commands modify state through aggregate methods?
- Do commands return minimal data (ID or void), not full entities?
- Do queries bypass aggregates for read-only data?
- Do queries project to DTOs, not return domain entities?
- Are handlers stateless and focused on a single use case?

**Source:** [CQRS Pattern with MediatR](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr), [CQRS and MediatR in ASP.NET Core](https://code-maze.com/cqrs-mediatr-in-aspnet-core/), [eShopOnContainers CQRS + DDD](https://learn.microsoft.com/th-th/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/eshoponcontainers-cqrs-ddd-microservice)

### Pattern 8: Vertical Slice Architecture Integration

**What:** Organize code by feature/use case rather than technical layers, with each slice owning its domain, application, and infrastructure concerns.

**Integration with DDD:**
- Each feature module = bounded context
- Slices within a feature = commands/queries
- Domain layer shared across slices in the same feature
- Infrastructure (DbContext) owned by feature, not centralized

**Audit checklist:**
- Are features isolated (no cross-feature domain dependencies)?
- Do slices share domain models within the same feature?
- Are there centralized "Core" or "Shared" domain models used by multiple features (potential bounded context violation)?
- Does each slice have minimal coupling to other slices?

**Source:** [Vertical Slice Architecture - Jimmy Bogard](https://www.jimmybogard.com/vertical-slice-architecture/), [Vertical Slice Architecture in .NET 10](https://nadirbad.dev/vertical-slice-architecture-dotnet), [Feature-Based Vertical Slice + CQRS + DDD](https://medium.com/@mervbayrak/feature-based-vertical-slice-cqrs-ddd-building-a-clean-architecture-in-net-97611feb274f)

### Anti-Patterns to Avoid

**Anemic Domain Model:**
- Domain entities with only getters/setters, no behavior
- Business logic in service/handler classes instead of aggregates
- Aggregates acting as data bags

**Large Aggregates:**
- Loading entire object graphs unnecessarily
- Poor performance and concurrency conflicts
- Many child entities when IDs would suffice

**Shared Kernel Anti-pattern:**
- Multiple bounded contexts sharing domain models
- Changes ripple across contexts
- Loss of autonomy

**Cross-Aggregate Transaction:**
- Modifying multiple aggregates in one transaction
- Breaks consistency boundary rules
- Should use eventual consistency + domain events

**Primitive Obsession:**
- Using string, int, Guid directly in domain instead of value objects
- Losing domain concepts and validation

**Sources:** [Anemic Domain Model - Martin Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html), [DDD Anti-patterns](https://alok-mishra.com/2021/11/03/ddd-anti-patterns/), [Common DDD Mistakes](https://www.kranio.io/en/blog/de-bueno-a-excelente-en-ddd-errores-comunes-y-anti-patrones-en-domain-driven-design---10-10)

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Value object equality | Manual Equals/GetHashCode | Abstract ValueObject base class or C# records | Handles null checks, type checking, component-wise comparison, hash code caching |
| Strongly-typed IDs | Wrapper classes per entity | Generic StronglyTypedId<T> base record | Records provide value equality, immutability, and minimal boilerplate |
| Domain event dispatching | Custom event bus | MediatR INotification + INotificationHandler | Industry-standard, well-tested, integrates with DI |
| Aggregate concurrency | Manual version checking | EF Core Timestamp attribute + xmin column | Automatic optimistic concurrency via database |
| Cross-context integration | Direct DbContext joins | MassTransit + event contracts | Maintains bounded context isolation, supports distributed systems |
| Ubiquitous language validation | Manual code review | NDepend rules (optional) | Automated verification that code uses domain vocabulary |

**Key insight:** DDD tactical patterns have mature .NET implementations. The value is in applying them correctly to the domain, not in building the infrastructure.

## Common Pitfalls

### Pitfall 1: Aggregate Boundary Confusion

**What goes wrong:** Aggregates too large (loading unnecessary data) or too small (requiring multi-aggregate transactions).

**Why it happens:** Unclear understanding of what constitutes a true invariant vs eventual consistency scenario.

**How to avoid:**
- Ask: "Does this rule need to be consistent in the same transaction?"
- If yes, same aggregate; if no, use domain events
- Prefer small aggregates with eventual consistency
- Reference other aggregates by ID only

**Warning signs:**
- Aggregates with many child entities (>3-5)
- Loading large object graphs for simple operations
- SaveChangesAsync called on multiple aggregates in one handler
- Concurrency conflicts in production

**Source:** [Effective Aggregate Design - Vernon](https://www.dddcommunity.org/library/vernon_2011/), [Designing DDD aggregates](https://medium.com/@allousas/designing-ddd-aggregates-db633f1caf88)

### Pitfall 2: Anemic Domain Model

**What goes wrong:** Domain entities have only properties with getters/setters. All business logic lives in command handlers or services.

**Why it happens:**
- CRUD mindset instead of behavior-focused design
- Fear of "fat" entities
- Misunderstanding separation of concerns

**How to avoid:**
- Behavior methods on aggregates (Create, Update, Submit, Approve, etc.)
- Private setters, public behavior methods
- Handlers orchestrate, aggregates execute business rules
- Ask: "Where should this validation/calculation live?" (usually the aggregate)

**Warning signs:**
- Entities with all public setters
- Handlers with complex business logic
- Comments like "Update product properties" in handlers
- No factory methods on aggregates

**Source:** [Anemic Domain Model - Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html), [Anemic vs Rich Domain Model](https://medium.com/@inzuael/anemic-domain-model-vs-rich-domain-model-78752b46098f)

### Pitfall 3: Leaky Bounded Context Boundaries

**What goes wrong:** Multiple feature modules share domain models, DbContexts query across contexts, or domain knowledge leaks between features.

**Why it happens:**
- Convenience (sharing models seems DRY)
- Misunderstanding bounded context independence
- Legacy refactoring incomplete

**How to avoid:**
- Each feature owns its domain model
- Cross-context data retrieved via events or dedicated queries
- Event contracts are NOT shared domain models (separate DTOs)
- Schema-per-feature isolation enforced

**Warning signs:**
- Shared "Common.Domain" folder used by multiple features
- DbContext joins across schemas
- Direct references to other feature's entities
- Feature A importing Feature B's domain namespace

**Source:** [Bounded Context - Fowler](https://martinfowler.com/bliki/BoundedContext.html), [Microservices Anti-Patterns](https://dzone.com/articles/10-microservices-anti-patterns-you-need-to-avoid)

### Pitfall 4: Ubiquitous Language Drift

**What goes wrong:** Code uses technical names instead of domain terms, or the same term has different meanings in different contexts.

**Why it happens:**
- Insufficient domain expert collaboration
- Developer convenience over domain accuracy
- Copy-paste from other projects

**How to avoid:**
- Domain experts review code/naming
- Glossary per bounded context
- Consistent terminology in class names, methods, and variables
- Code review focus on language alignment

**Warning signs:**
- Generic names like "Manager", "Service", "Processor" for domain concepts
- Technical jargon in domain layer ("DTO", "Entity", "Model" suffixes)
- Same business concept named differently across features
- Business stakeholders don't understand class names

**Source:** [Ubiquitous Language - Fowler](https://martinfowler.com/bliki/UbiquitousLanguage.html), [Ubiquitous Language and Naming](https://enterprisecraftsmanship.com/posts/ubiquitous-language-naming/), [Checking DDD Ubiquitous Language with NDepend](https://blog.ndepend.com/checking-ddd-ubiquitous-language-with-ndepend/)

### Pitfall 5: Command/Query Confusion (CQRS)

**What goes wrong:** Commands return full entities, queries mutate state, or handlers mix read and write concerns.

**Why it happens:**
- Convenience (returning created object saves a query)
- Misunderstanding CQRS boundaries
- Frontend expectations driving backend design

**How to avoid:**
- Commands return ID or void
- Queries are read-only (no SaveChangesAsync)
- Commands modify through aggregate methods
- Queries can bypass aggregates for performance

**Warning signs:**
- Command handlers returning entities/DTOs
- Query handlers calling SaveChangesAsync
- Command handlers with complex projections
- Queries loading aggregates and modifying them

**Source:** [CQRS with MediatR](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr), [Stop Conflating CQRS and MediatR](https://www.milanjovanovic.tech/blog/stop-conflating-cqrs-and-mediatr)

### Pitfall 6: Domain Events Published Before Persistence

**What goes wrong:** Events published before SaveChangesAsync succeeds, causing handlers to react to changes that may roll back.

**Why it happens:**
- Eager event publishing for performance
- Misunderstanding transactional boundaries
- No outbox pattern

**How to avoid:**
- Collect domain events during aggregate operations
- Publish events in SaveChangesAsync override or interceptor
- Use outbox pattern for reliable cross-service events
- MassTransit integration after successful save

**Warning signs:**
- Events published in aggregate methods
- Event handlers fail but aggregate changes persisted
- Duplicate processing when transactions retry
- Events with data that doesn't match database state

**Source:** [Domain events: Design and implementation](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

### Pitfall 7: Value Object Mutability

**What goes wrong:** Value objects have public setters, allowing in-place modification instead of replacement.

**Why it happens:**
- ORM requirements misunderstood
- Convenience (mutating seems simpler)
- Inheritance from old patterns

**How to avoid:**
- Private setters or init-only properties
- C# records for immutability by default
- Replace entire value object instead of modifying
- EF Core backing fields for owned entities

**Warning signs:**
- Value objects with public setters
- Methods that modify value object state
- Value objects without proper equality
- Mutable collections in value objects

**Source:** [Value Object Better Implementation](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/), [Creating DDD entity classes with EF Core](https://www.thereformedprogrammer.net/creating-domain-driven-design-entity-classes-with-entity-framework-core/)

## Code Examples

These are reference patterns from authoritative sources that should be compared against the codebase implementation.

### Aggregate Root Pattern
```csharp
// Source: eShopOnContainers + Vernon's Effective Aggregate Design
public abstract class AggregateRoot<TId>
{
    private readonly List<DomainEvent> _domainEvents = [];

    public TId Id { get; protected init; }
    public IReadOnlyCollection<DomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    protected void AddDomainEvent(DomainEvent domainEvent) => _domainEvents.Add(domainEvent);
    public void ClearDomainEvents() => _domainEvents.Clear();
}

// Factory method + invariant enforcement
public class Order : AggregateRoot<OrderId>
{
    private readonly List<OrderItem> _items = [];

    public static Order Create(Guid buyerId, Address address, IEnumerable<CartItem> items)
    {
        var order = new Order(OrderId.New()) { BuyerId = buyerId, Address = address };
        foreach (var item in items)
        {
            order.AddItem(item.ProductId, item.Quantity, item.UnitPrice);
        }

        if (order._items.Count == 0)
            throw new InvalidOperationException("Order must have at least one item");

        order.AddDomainEvent(new OrderCreatedEvent(order.Id));
        return order;
    }

    // Private constructor prevents invalid creation
    private Order(OrderId id) { Id = id; }
}
```
**Source:** [Microsoft Learn - Implementing a microservice domain model with .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

### Value Object Pattern
```csharp
// Source: Enterprise Craftsmanship (Vladimir Khorikov)
public abstract class ValueObject
{
    protected abstract IEnumerable<object> GetEqualityComponents();

    public override bool Equals(object obj)
    {
        if (obj == null || obj.GetType() != GetType())
            return false;

        var other = (ValueObject)obj;
        return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
    }

    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Aggregate(1, (current, obj) =>
                HashCode.Combine(current, obj?.GetHashCode() ?? 0));
    }
}

// Modern alternative: readonly record struct
public readonly record struct Money(decimal Amount, string Currency);
```
**Source:** [Value Object Better Implementation](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)

### Strongly-Typed ID Pattern
```csharp
// Source: Andrew Lock
public abstract record StronglyTypedId<T>(T Value)
{
    public override string ToString() => Value?.ToString() ?? string.Empty;
}

public record ProductId(Guid Value) : StronglyTypedId<Guid>(Value)
{
    public static ProductId New() => new(Guid.NewGuid());
}

// EF Core configuration
builder.Property(p => p.Id)
    .HasConversion(
        id => id.Value,
        value => new ProductId(value));
```
**Source:** [Using strongly-typed entity IDs to avoid primitive obsession](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)

### Domain Event Pattern
```csharp
// Source: Microsoft eShopOnContainers
public interface IDomainEvent : INotification
{
    Guid EventId { get; }
    DateTimeOffset OccurredOn { get; }
}

public record OrderSubmittedEvent(OrderId OrderId) : IDomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTimeOffset OccurredOn { get; } = DateTimeOffset.UtcNow;
}

// Publishing after SaveChanges
public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    int result = await base.SaveChangesAsync(cancellationToken);

    // Dispatch domain events AFTER successful save
    await _domainEventDispatcher.DispatchEventsAsync(this, cancellationToken);

    return result;
}
```
**Source:** [Domain events: Design and implementation](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Generic Repository<T> | DbContext direct injection or specific repositories | 2020+ | Simplified architecture, EF Core already implements Repository + Unit of Work |
| Class-based value objects | C# record structs | C# 9/10 (2020-2021) | Immutability by default, structural equality, less boilerplate |
| Manual strongly-typed ID wrappers | record StronglyTypedId<T>(T Value) | C# 9+ (2020) | One-line implementation with full value semantics |
| Manual domain event dispatching | MediatR INotification integration | MediatR 9+ (2020) | Standard pipeline, automatic handler discovery |
| Layered architecture | Vertical slice architecture | 2019+ (Jimmy Bogard) | Feature-based organization, better cohesion |
| Shared database | Database-per-service/feature | DDD/microservices movement | Bounded context isolation, independent evolution |

**Deprecated/outdated:**
- **Generic Repository<T> with IQueryable leakage** - Modern approach: inject DbContext directly (per Microsoft guidance) or use specific repositories
- **Class-based strongly-typed IDs with manual equality** - Use C# records for concise, immutable value types
- **Domain events published before SaveChanges** - Use outbox pattern or interceptors to ensure transactional consistency

## Open Questions

1. **BuildingBlocks.Common entity base class existence**
   - What we know: Codebase has BaseAggregateRoot but no visible Entity base class
   - What's unclear: Are child entities (OrderItem, CartItem) using a base Entity class or are they plain classes?
   - Recommendation: Audit should check if child entities have identity management and if they need a common base

2. **Outbox pattern implementation**
   - What we know: Codebase has Common/Persistence/OutboxDbContext.cs
   - What's unclear: Is it fully implemented? Are domain events reliably published?
   - Recommendation: Verify domain event publishing happens after SaveChanges with outbox guarantees

3. **Repository abstraction level**
   - What we know: DbContext injected directly into handlers (no explicit repository interfaces found)
   - What's unclear: Is this intentional (eShopOnContainers simplified approach) or incomplete?
   - Recommendation: Validate against modern .NET guidance that DbContext direct injection is acceptable for CQRS

4. **Cross-context integration patterns**
   - What we know: MassTransit configured, separate DbContexts exist
   - What's unclear: Are event contracts properly separated from domain models? Is anti-corruption layer present?
   - Recommendation: Deep audit of event contracts and cross-feature dependencies

## Sources

### Primary (HIGH confidence)

- [Using tactical DDD to design microservices - Microsoft Azure Architecture Center](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd)
- [Effective Aggregate Design by Vaughn Vernon - DDD Community](https://www.dddcommunity.org/library/vernon_2011/)
- [Aggregate Design Rules according to Vaughn Vernon - ArchiLab](https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html)
- [Implementing a microservice domain model with .NET - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)
- [Infrastructure persistence layer with Entity Framework Core - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-implementation-entity-framework-core)
- [Domain events: Design and implementation - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation)
- [eShopOnContainers CQRS and DDD microservice - Microsoft Learn](https://learn.microsoft.com/th-th/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/eshoponcontainers-cqrs-ddd-microservice)

### Secondary (MEDIUM confidence)

- [Value Object Better Implementation - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/value-object-better-implementation/)
- [Using strongly-typed entity IDs to avoid primitive obsession - Andrew Lock](https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/)
- [Anemic Domain Model - Martin Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html)
- [Bounded Context - Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)
- [Ubiquitous Language - Martin Fowler](https://martinfowler.com/bliki/UbiquitousLanguage.html)
- [CQRS Pattern with MediatR - Milan Jovanovic](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)
- [CQRS and MediatR in ASP.NET Core - Code Maze](https://code-maze.com/cqrs-mediatr-in-aspnet-core/)
- [Vertical Slice Architecture - Jimmy Bogard](https://www.jimmybogard.com/vertical-slice-architecture/)
- [Vertical Slice Architecture in .NET 10 - Nadir Badnjevic](https://nadirbad.dev/vertical-slice-architecture-dotnet)
- [Is the repository pattern useful with Entity Framework Core? - Reformed Programmer](https://www.thereformedprogrammer.net/is-the-repository-pattern-useful-with-entity-framework-core/)

### Tertiary (LOW confidence)

- [DDD Anti-patterns - Alok Mishra](https://alok-mishra.com/2021/11/03/ddd-anti-patterns/) - Community blog, needs verification
- [Common DDD Mistakes - Kranio](https://www.kranio.io/en/blog/de-bueno-a-excelente-en-ddd-errores-comunes-y-anti-patrones-en-domain-driven-design---10-10) - Translation quality uncertain

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - BuildingBlocks layer verified in codebase, MediatR/EF Core standard
- Architecture: HIGH - Patterns verified via Microsoft docs and Vaughn Vernon official sources
- Pitfalls: HIGH - Cross-referenced with Fowler, Microsoft, and community consensus

**Research date:** 2026-02-14
**Valid until:** 30 days (DDD tactical patterns are stable; .NET 10 patterns current)

**Audit complexity estimate:** 7 feature modules × 6-8 pattern categories × 2-3 severity levels = 80-150 individual findings expected across the codebase, depending on implementation maturity.
