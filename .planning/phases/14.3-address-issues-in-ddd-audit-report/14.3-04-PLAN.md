---
phase: 14.3-address-issues-in-ddd-audit-report
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Product.cs
  - src/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/ProductConfiguration.cs
  - src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProductById/GetProductByIdQueryHandler.cs
  - src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProducts/GetProductsQueryHandler.cs
  - src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProducts/ProductListDto.cs
autonomous: true

must_haves:
  truths:
    - "Product entity has no navigation property to Category (reference by identity only, per Vernon Rule 3)"
    - "Product queries use a manual join to get CategoryName instead of navigation property"
    - "All product query results still include CategoryId and CategoryName"
    - "Frontend product listing and detail pages still display category name correctly"
  artifacts:
    - path: "src/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Product.cs"
      provides: "Product without Category navigation property"
    - path: "src/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/ProductConfiguration.cs"
      provides: "FK constraint without navigation"
    - path: "src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProductById/GetProductByIdQueryHandler.cs"
      provides: "Query with manual join for category name"
    - path: "src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProducts/GetProductsQueryHandler.cs"
      provides: "Query with manual join for category name"
  key_links:
    - from: "GetProductByIdQueryHandler"
      to: "CatalogDbContext Categories"
      via: "LINQ join instead of navigation"
      pattern: "join.*Categories"
    - from: "GetProductsQueryHandler"
      to: "CatalogDbContext Categories"
      via: "LINQ join instead of navigation"
      pattern: "join.*Categories"
---

<objective>
Remove the Product-to-Category navigation property and replace it with reference-by-identity, following Vernon's Aggregate Design Rule 3 ("Reference other aggregates by identity only").

Purpose: Product and Category are both aggregate roots. DDD dictates that aggregates should reference each other by identity, not by direct object reference. The navigation property creates tight coupling between aggregates and allows queries to traverse aggregate boundaries. Removing it enforces proper aggregate isolation while keeping the foreign key for referential integrity.

Output: Product entity references Category only via CategoryId. Queries use explicit joins to fetch category names when needed.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Product.cs
@src/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/ProductConfiguration.cs
@src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProductById/GetProductByIdQueryHandler.cs
@src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProducts/GetProductsQueryHandler.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove Category navigation property from Product entity and update EF configuration</name>
  <files>
    src/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Product.cs
    src/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/ProductConfiguration.cs
  </files>
  <action>
    1. In Product.cs: Remove the line `public Category? Category { get; private set; }`. This is the navigation property that violates Vernon Rule 3. The `CategoryId` property remains — it's the identity-based reference. No other changes to Product.cs.

    2. In ProductConfiguration.cs: Replace the navigation-based relationship:
       ```csharp
       builder.HasOne(p => p.Category)
           .WithMany()
           .HasForeignKey(p => p.CategoryId)
           .OnDelete(DeleteBehavior.Restrict);
       ```
       With a shadow-property-based foreign key constraint (no navigation, just FK):
       ```csharp
       builder.HasOne<Category>()
           .WithMany()
           .HasForeignKey(p => p.CategoryId)
           .OnDelete(DeleteBehavior.Restrict);
       ```
       This preserves the database FK constraint for referential integrity without requiring a navigation property on the domain entity. The `HasOne<Category>()` overload specifies the related type without a navigation property selector.

    Note: No EF migration is needed — the database schema is unchanged (same FK, same constraint). Only the C# mapping changes.
  </action>
  <verify>
    Run `dotnet build src/MicroCommerce.ApiService` — must compile. Any compilation errors in query handlers are expected and will be fixed in Task 2.
    Verify no migration is generated: `dotnet ef migrations has-pending-model-changes --project src/MicroCommerce.ApiService` (if this command is available) or confirm schema snapshot is unchanged.
  </verify>
  <done>
    Product entity has no Category navigation property. ProductConfiguration uses `HasOne<Category>()` without navigation selector. FK constraint preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update product queries to use explicit joins for category name</name>
  <files>
    src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProductById/GetProductByIdQueryHandler.cs
    src/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProducts/GetProductsQueryHandler.cs
  </files>
  <action>
    1. In GetProductByIdQueryHandler.cs: Replace the `.Include(p => p.Category)` and `p.Category!.Name.Value` pattern with a LINQ join:
       ```csharp
       var product = await (
           from p in _context.Products.AsNoTracking()
           join c in _context.Categories.AsNoTracking() on p.CategoryId equals c.Id
           where p.Id == new ProductId(request.Id)
           select new ProductDto(
               p.Id.Value,
               p.Name.Value,
               p.Description,
               p.Price.Amount,
               p.Price.Currency,
               p.ImageUrl,
               p.Sku,
               p.Status.ToString(),
               p.CategoryId.Value,
               c.Name.Value,
               p.CreatedAt,
               p.UpdatedAt,
               p.AverageRating,
               p.ReviewCount)
       ).FirstOrDefaultAsync(cancellationToken);
       ```
       Remove the `.Include(p => p.Category)` line entirely.

    2. In GetProductsQueryHandler.cs: This is more complex because of the filtering, sorting, and pagination. Restructure to use a join. The key changes:
       - Remove `.Include(p => p.Category)`
       - Build the base query as a join between Products and Categories
       - Apply filters, sorting, and pagination on the joined query
       - Select into ProductDto using `c.Name.Value` for category name

       Approach: Use a LINQ query syntax join and then apply method-syntax filters on top:
       ```csharp
       var baseQuery = from p in _context.Products.AsNoTracking()
                       join c in _context.Categories.AsNoTracking() on p.CategoryId equals c.Id
                       select new { Product = p, CategoryName = c.Name.Value };
       ```
       Then apply filters on `baseQuery.Where(x => x.Product.CategoryId == ...)` etc.
       For sorting, apply on `baseQuery.OrderBy(x => x.Product.Price.Amount)` etc.
       For the final Select, map to ProductDto using `x.Product.*` and `x.CategoryName`.

       Make sure the EF Core translation works by keeping the query simple and using the anonymous type pattern. The previous `query` variable was `IQueryable<Product>` — now it becomes `IQueryable<anonymous>` with Product and CategoryName.
  </action>
  <verify>
    Run `dotnet build src/MicroCommerce.ApiService` — must compile without errors.
    Run `dotnet test src/MicroCommerce.ApiService.Tests` — all tests pass.
    Grep for `.Category` in the Catalog feature queries — should return 0 results for navigation access patterns.
  </verify>
  <done>
    Both GetProductById and GetProducts queries use explicit LINQ joins instead of Category navigation property. Queries return the same ProductDto shape with CategoryId and CategoryName. Solution builds and tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` at solution root succeeds with zero errors
2. `dotnet test src/MicroCommerce.ApiService.Tests` — all tests pass
3. Grep for `p\.Category` or `\.Category!` in Catalog query handlers returns 0 results
4. Grep for `Include.*Category` in Catalog query handlers returns 0 results
5. Product.cs does not contain `Category? Category` property
6. ProductDto still has CategoryId and CategoryName fields (query result shape unchanged)
</verification>

<success_criteria>
Product entity references Category by identity only (CategoryId). No navigation property exists. Query handlers use explicit joins to fetch category names. FK constraint preserved in database. All tests pass and the API returns the same data shape.
</success_criteria>

<output>
After completion, create `.planning/phases/14.3-address-issues-in-ddd-audit-report/14.3-04-SUMMARY.md`
</output>
