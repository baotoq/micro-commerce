---
phase: 02-catalog-domain-admin-crud
plan: 06
title: Admin UI - Product Drawer (Create/Edit)
wave: 2
depends_on: [02-05]
files_modified:
  - code/MicroCommerce.Web/src/components/admin/product-drawer.tsx
  - code/MicroCommerce.Web/src/components/admin/image-upload.tsx
  - code/MicroCommerce.Web/src/app/admin/products/page.tsx
  - code/MicroCommerce.Web/src/lib/api.ts
autonomous: true
estimated_duration: 20min
must_haves:
  - Slide-out drawer component for create/edit
  - Product form with all fields (name, description, price, category, image, SKU)
  - Image upload with preview
  - Form validation with error messages
  - Loading state during save
  - Success/error feedback
---

# Plan 02-06: Admin UI - Product Drawer (Create/Edit)

**Objective:** Implement the slide-out drawer for creating and editing products with image upload.

## Context

Per user vision (02-CONTEXT.md):
- Slide-out drawer for create/edit forms
- More space than modal, can show product preview
- Image upload to Azure Blob Storage

This plan completes the admin CRUD UI by adding the create/edit drawer.

## Tasks

<task id="1" title="Install additional shadcn components">
Add components needed for the drawer and form.

```bash
cd code/MicroCommerce.Web
npx shadcn@latest add sheet --yes
npx shadcn@latest add label --yes
npx shadcn@latest add textarea --yes
npx shadcn@latest add toast --yes
npx shadcn@latest add sonner --yes
```

**Verification:**
- [ ] Sheet component installed (drawer)
- [ ] Form components installed
- [ ] Toast for notifications
</task>

<task id="2" title="Add API functions for create/update/upload">
Extend API client with mutation functions.

**Update:** `src/lib/api.ts`

Add these functions:

```typescript
export interface CreateProductRequest {
  name: string;
  description: string;
  price: number;
  categoryId: string;
  imageUrl?: string;
  sku?: string;
}

export interface UpdateProductRequest extends CreateProductRequest {}

export async function createProduct(data: CreateProductRequest): Promise<{ id: string }> {
  const response = await fetch(`${API_BASE}/api/catalog/products`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Failed to create product');
  }

  return response.json();
}

export async function updateProduct(id: string, data: UpdateProductRequest): Promise<void> {
  const response = await fetch(`${API_BASE}/api/catalog/products/${id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Failed to update product');
  }
}

export async function uploadImage(file: File): Promise<string> {
  const formData = new FormData();
  formData.append('file', file);

  const response = await fetch(`${API_BASE}/api/catalog/images`, {
    method: 'POST',
    body: formData,
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Failed to upload image');
  }

  const result = await response.json();
  return result.imageUrl;
}
```

**Verification:**
- [ ] createProduct sends POST request
- [ ] updateProduct sends PUT request
- [ ] uploadImage sends multipart form data
- [ ] Error messages extracted from response
</task>

<task id="3" title="Create ImageUpload component">
Create component for image upload with preview.

**File:** `src/components/admin/image-upload.tsx`

```tsx
'use client';

import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import { Button } from '@/components/ui/button';
import { Upload, X, Loader2 } from 'lucide-react';
import { uploadImage } from '@/lib/api';

interface ImageUploadProps {
  value?: string;
  onChange: (url: string | undefined) => void;
  disabled?: boolean;
}

export function ImageUpload({ value, onChange, disabled }: ImageUploadProps) {
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = useCallback(async (file: File) => {
    // Validate file type
    if (!file.type.startsWith('image/')) {
      setError('Please select an image file');
      return;
    }

    // Validate file size (5MB)
    if (file.size > 5 * 1024 * 1024) {
      setError('Image must be less than 5MB');
      return;
    }

    setError(null);
    setUploading(true);

    try {
      const imageUrl = await uploadImage(file);
      onChange(imageUrl);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setUploading(false);
    }
  }, [onChange]);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) handleFileSelect(file);
  }, [handleFileSelect]);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
  }, []);

  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) handleFileSelect(file);
  }, [handleFileSelect]);

  const handleRemove = useCallback(() => {
    onChange(undefined);
    if (inputRef.current) inputRef.current.value = '';
  }, [onChange]);

  return (
    <div className="space-y-2">
      {value ? (
        <div className="relative w-full aspect-video bg-gray-100 rounded-lg overflow-hidden">
          <Image
            src={value}
            alt="Product image"
            fill
            className="object-contain"
          />
          <Button
            type="button"
            variant="destructive"
            size="icon"
            className="absolute top-2 right-2"
            onClick={handleRemove}
            disabled={disabled || uploading}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      ) : (
        <div
          className={`
            border-2 border-dashed rounded-lg p-8 text-center
            ${disabled ? 'bg-gray-50 cursor-not-allowed' : 'hover:border-gray-400 cursor-pointer'}
            ${error ? 'border-red-300' : 'border-gray-300'}
          `}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          onClick={() => !disabled && inputRef.current?.click()}
        >
          {uploading ? (
            <div className="flex flex-col items-center">
              <Loader2 className="h-8 w-8 text-gray-400 animate-spin" />
              <p className="mt-2 text-sm text-gray-500">Uploading...</p>
            </div>
          ) : (
            <div className="flex flex-col items-center">
              <Upload className="h-8 w-8 text-gray-400" />
              <p className="mt-2 text-sm text-gray-600">
                Click to upload or drag and drop
              </p>
              <p className="text-xs text-gray-400">
                PNG, JPG, GIF, WebP up to 5MB
              </p>
            </div>
          )}
        </div>
      )}

      <input
        ref={inputRef}
        type="file"
        accept="image/*"
        className="hidden"
        onChange={handleInputChange}
        disabled={disabled || uploading}
      />

      {error && (
        <p className="text-sm text-red-500">{error}</p>
      )}
    </div>
  );
}
```

**Verification:**
- [ ] Click to select file works
- [ ] Drag and drop works
- [ ] Preview shows after upload
- [ ] Remove button clears image
- [ ] Loading state during upload
- [ ] Error messages display
</task>

<task id="4" title="Create ProductDrawer component">
Create the main drawer component with form.

**File:** `src/components/admin/product-drawer.tsx`

```tsx
'use client';

import { useState, useEffect } from 'react';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Loader2 } from 'lucide-react';
import { ImageUpload } from './image-upload';
import {
  ProductDto,
  CategoryDto,
  createProduct,
  updateProduct,
  CreateProductRequest,
} from '@/lib/api';
import { toast } from 'sonner';

interface ProductDrawerProps {
  open: boolean;
  onClose: () => void;
  product: ProductDto | null;
  categories: CategoryDto[];
  onSave: () => void;
}

interface FormData {
  name: string;
  description: string;
  price: string;
  categoryId: string;
  imageUrl: string;
  sku: string;
}

interface FormErrors {
  name?: string;
  description?: string;
  price?: string;
  categoryId?: string;
}

const initialFormData: FormData = {
  name: '',
  description: '',
  price: '',
  categoryId: '',
  imageUrl: '',
  sku: '',
};

export function ProductDrawer({
  open,
  onClose,
  product,
  categories,
  onSave,
}: ProductDrawerProps) {
  const [formData, setFormData] = useState<FormData>(initialFormData);
  const [errors, setErrors] = useState<FormErrors>({});
  const [saving, setSaving] = useState(false);

  const isEditing = !!product;

  // Reset form when drawer opens/closes or product changes
  useEffect(() => {
    if (open && product) {
      setFormData({
        name: product.name,
        description: product.description,
        price: product.price.toString(),
        categoryId: product.categoryId,
        imageUrl: product.imageUrl || '',
        sku: product.sku || '',
      });
    } else if (open) {
      setFormData(initialFormData);
    }
    setErrors({});
  }, [open, product]);

  const validate = (): boolean => {
    const newErrors: FormErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Name is required';
    } else if (formData.name.length < 2) {
      newErrors.name = 'Name must be at least 2 characters';
    } else if (formData.name.length > 200) {
      newErrors.name = 'Name cannot exceed 200 characters';
    }

    if (!formData.description.trim()) {
      newErrors.description = 'Description is required';
    } else if (formData.description.length > 4000) {
      newErrors.description = 'Description cannot exceed 4000 characters';
    }

    const price = parseFloat(formData.price);
    if (isNaN(price)) {
      newErrors.price = 'Price must be a number';
    } else if (price < 0) {
      newErrors.price = 'Price cannot be negative';
    }

    if (!formData.categoryId) {
      newErrors.categoryId = 'Category is required';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validate()) return;

    setSaving(true);

    try {
      const data: CreateProductRequest = {
        name: formData.name.trim(),
        description: formData.description.trim(),
        price: parseFloat(formData.price),
        categoryId: formData.categoryId,
        imageUrl: formData.imageUrl || undefined,
        sku: formData.sku.trim() || undefined,
      };

      if (isEditing) {
        await updateProduct(product.id, data);
        toast.success('Product updated successfully');
      } else {
        await createProduct(data);
        toast.success('Product created successfully');
      }

      onSave();
      onClose();
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to save product');
    } finally {
      setSaving(false);
    }
  };

  const handleChange = (field: keyof FormData, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    // Clear error when user types
    if (errors[field as keyof FormErrors]) {
      setErrors((prev) => ({ ...prev, [field]: undefined }));
    }
  };

  return (
    <Sheet open={open} onOpenChange={(isOpen) => !isOpen && onClose()}>
      <SheetContent className="w-full sm:max-w-lg overflow-y-auto">
        <SheetHeader>
          <SheetTitle>{isEditing ? 'Edit Product' : 'Add Product'}</SheetTitle>
          <SheetDescription>
            {isEditing
              ? 'Update the product details below.'
              : 'Fill in the details to create a new product.'}
          </SheetDescription>
        </SheetHeader>

        <form onSubmit={handleSubmit} className="mt-6 space-y-6">
          {/* Image Upload */}
          <div className="space-y-2">
            <Label>Product Image</Label>
            <ImageUpload
              value={formData.imageUrl || undefined}
              onChange={(url) => handleChange('imageUrl', url || '')}
              disabled={saving}
            />
          </div>

          {/* Name */}
          <div className="space-y-2">
            <Label htmlFor="name">Name *</Label>
            <Input
              id="name"
              value={formData.name}
              onChange={(e) => handleChange('name', e.target.value)}
              placeholder="Product name"
              disabled={saving}
              className={errors.name ? 'border-red-500' : ''}
            />
            {errors.name && (
              <p className="text-sm text-red-500">{errors.name}</p>
            )}
          </div>

          {/* Description */}
          <div className="space-y-2">
            <Label htmlFor="description">Description *</Label>
            <Textarea
              id="description"
              value={formData.description}
              onChange={(e) => handleChange('description', e.target.value)}
              placeholder="Product description"
              rows={4}
              disabled={saving}
              className={errors.description ? 'border-red-500' : ''}
            />
            {errors.description && (
              <p className="text-sm text-red-500">{errors.description}</p>
            )}
          </div>

          {/* Price */}
          <div className="space-y-2">
            <Label htmlFor="price">Price (USD) *</Label>
            <Input
              id="price"
              type="number"
              step="0.01"
              min="0"
              value={formData.price}
              onChange={(e) => handleChange('price', e.target.value)}
              placeholder="0.00"
              disabled={saving}
              className={errors.price ? 'border-red-500' : ''}
            />
            {errors.price && (
              <p className="text-sm text-red-500">{errors.price}</p>
            )}
          </div>

          {/* Category */}
          <div className="space-y-2">
            <Label htmlFor="category">Category *</Label>
            <Select
              value={formData.categoryId}
              onValueChange={(value) => handleChange('categoryId', value)}
              disabled={saving}
            >
              <SelectTrigger className={errors.categoryId ? 'border-red-500' : ''}>
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                {categories.map((category) => (
                  <SelectItem key={category.id} value={category.id}>
                    {category.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {errors.categoryId && (
              <p className="text-sm text-red-500">{errors.categoryId}</p>
            )}
          </div>

          {/* SKU */}
          <div className="space-y-2">
            <Label htmlFor="sku">SKU (optional)</Label>
            <Input
              id="sku"
              value={formData.sku}
              onChange={(e) => handleChange('sku', e.target.value)}
              placeholder="Product SKU"
              disabled={saving}
            />
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-3 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={onClose}
              disabled={saving}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={saving}>
              {saving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {isEditing ? 'Update Product' : 'Create Product'}
            </Button>
          </div>
        </form>
      </SheetContent>
    </Sheet>
  );
}
```

**Verification:**
- [ ] Drawer slides in from right
- [ ] Form pre-populated when editing
- [ ] Form cleared when creating
- [ ] Validation errors display
- [ ] Loading state during save
- [ ] Toast notifications on success/error
</task>

<task id="5" title="Add Toaster to layout">
Add toast provider to the app.

**Update:** `src/app/admin/layout.tsx`

Add Toaster component:

```tsx
import { Toaster } from 'sonner';

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-gray-50">
      {/* ... existing layout ... */}
      <Toaster position="top-right" />
    </div>
  );
}
```

**Verification:**
- [ ] Toast notifications appear
- [ ] Positioned correctly
</task>

<task id="6" title="Integrate drawer into Products page">
Connect the drawer to the products page.

**Update:** `src/app/admin/products/page.tsx`

Uncomment and update the drawer integration:

```tsx
// Add import at top
import { ProductDrawer } from '@/components/admin/product-drawer';

// In the return statement, add the drawer component:
{/* Drawer for create/edit */}
<ProductDrawer
  open={isDrawerOpen}
  onClose={() => {
    setIsDrawerOpen(false);
    setEditingProduct(null);
  }}
  product={editingProduct}
  categories={categories}
  onSave={fetchProducts}
/>
```

**Verification:**
- [ ] Add Product button opens drawer
- [ ] Edit action opens drawer with product data
- [ ] Drawer closes on cancel
- [ ] Product list refreshes after save
</task>

<task id="7" title="Configure Next.js for external images">
Allow external images from blob storage.

**Update:** `code/MicroCommerce.Web/next.config.ts`

```typescript
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'http',
        hostname: '127.0.0.1',
        port: '10000', // Azurite default port
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: '*.blob.core.windows.net',
        pathname: '/**',
      },
    ],
  },
};

export default nextConfig;
```

**Verification:**
- [ ] Images from Azurite display
- [ ] Images from Azure Blob Storage display
</task>

## Verification Criteria

1. **Create flow works:**
   - Click Add Product
   - Fill form with valid data
   - Upload image
   - Submit creates product
   - Toast shows success
   - List refreshes

2. **Edit flow works:**
   - Click Edit on existing product
   - Form pre-populated
   - Make changes
   - Submit updates product
   - Toast shows success
   - List refreshes

3. **Validation works:**
   - Empty required fields show errors
   - Invalid price shows error
   - Errors clear when corrected

4. **Image upload works:**
   - Click to select file
   - Drag and drop file
   - Preview displays
   - Remove button works
   - Upload errors display

5. **UX polish:**
   - Loading states visible
   - Disabled during save
   - Toast notifications appear
   - Drawer animates smoothly

## Dependencies

- Plan 02-05 (Products page structure)
- Plans 02-01, 02-02, 02-03 (API endpoints)

## Notes

- Using Sonner for toast notifications (recommended by shadcn)
- Form validation is client-side (server also validates)
- Image upload is separate from product save (upload first, get URL)
- Products start as Draft status when created
- Drawer uses shadcn Sheet component

