---
phase: 02-catalog-domain-admin-crud
plan: 02
title: Product CRUD Commands & Queries
wave: 1
depends_on: [02-01]
files_modified:
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/CreateProduct/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/UpdateProduct/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/ChangeProductStatus/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/ArchiveProduct/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProducts/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetProductById/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
autonomous: true
estimated_duration: 20min
must_haves:
  - CreateProduct command with validation
  - UpdateProduct command with validation
  - ChangeProductStatus command (publish/unpublish)
  - ArchiveProduct command (soft delete)
  - GetProducts query with filtering and pagination
  - GetProductById query
  - All endpoints wired in CatalogEndpoints
---

# Plan 02-02: Product CRUD Commands & Queries

**Objective:** Implement complete CQRS stack for Product management following established patterns from Category.

## Context

This plan creates the application layer for Product CRUD operations. Following the CQRS guidelines:
- Commands for mutations (Create, Update, ChangeStatus, Archive)
- Queries for reads (GetProducts with filters, GetProductById)
- DTOs for API responses
- FluentValidation for input validation

## Tasks

<task id="1" title="Create ProductDto and response types">
Create DTOs for Product API responses.

**File:** `Features/Catalog/Application/Queries/GetProducts/ProductDto.cs`

```csharp
public sealed record ProductDto(
    Guid Id,
    string Name,
    string Description,
    decimal Price,
    string PriceCurrency,
    string? ImageUrl,
    string? Sku,
    string Status,
    Guid CategoryId,
    string CategoryName,
    DateTimeOffset CreatedAt,
    DateTimeOffset? UpdatedAt);
```

**File:** `Features/Catalog/Application/Queries/GetProducts/ProductListDto.cs`

```csharp
public sealed record ProductListDto(
    IReadOnlyList<ProductDto> Items,
    int TotalCount,
    int Page,
    int PageSize);
```

**Verification:**
- [ ] ProductDto includes all display fields
- [ ] CategoryName included for display (denormalized)
- [ ] ProductListDto supports pagination metadata
</task>

<task id="2" title="Create GetProducts query with filtering">
Implement paginated product listing with filters.

**File:** `Features/Catalog/Application/Queries/GetProducts/GetProductsQuery.cs`

```csharp
public sealed record GetProductsQuery(
    int Page = 1,
    int PageSize = 20,
    Guid? CategoryId = null,
    string? Status = null,
    string? Search = null) : IRequest<ProductListDto>;
```

**File:** `Features/Catalog/Application/Queries/GetProducts/GetProductsQueryHandler.cs`

```csharp
public sealed class GetProductsQueryHandler
    : IRequestHandler<GetProductsQuery, ProductListDto>
{
    private readonly CatalogDbContext _context;

    public GetProductsQueryHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<ProductListDto> Handle(
        GetProductsQuery request,
        CancellationToken cancellationToken)
    {
        var query = _context.Products
            .AsNoTracking()
            .Include(p => p.Category)
            .AsQueryable();

        // Apply filters
        if (request.CategoryId.HasValue)
        {
            query = query.Where(p => p.CategoryId == new CategoryId(request.CategoryId.Value));
        }

        if (!string.IsNullOrWhiteSpace(request.Status) &&
            Enum.TryParse<ProductStatus>(request.Status, true, out var status))
        {
            query = query.Where(p => p.Status == status);
        }

        if (!string.IsNullOrWhiteSpace(request.Search))
        {
            var searchLower = request.Search.ToLower();
            query = query.Where(p =>
                p.Name.Value.ToLower().Contains(searchLower) ||
                p.Description.ToLower().Contains(searchLower) ||
                (p.Sku != null && p.Sku.ToLower().Contains(searchLower)));
        }

        var totalCount = await query.CountAsync(cancellationToken);

        var items = await query
            .OrderByDescending(p => p.CreatedAt)
            .Skip((request.Page - 1) * request.PageSize)
            .Take(request.PageSize)
            .Select(p => new ProductDto(
                p.Id.Value,
                p.Name.Value,
                p.Description,
                p.Price.Amount,
                p.Price.Currency,
                p.ImageUrl,
                p.Sku,
                p.Status.ToString(),
                p.CategoryId.Value,
                p.Category!.Name.Value,
                p.CreatedAt,
                p.UpdatedAt))
            .ToListAsync(cancellationToken);

        return new ProductListDto(items, totalCount, request.Page, request.PageSize);
    }
}
```

**Verification:**
- [ ] Pagination works correctly
- [ ] Category filter works
- [ ] Status filter works
- [ ] Search searches name, description, SKU
- [ ] Results ordered by CreatedAt descending
</task>

<task id="3" title="Create GetProductById query">
Implement single product retrieval.

**File:** `Features/Catalog/Application/Queries/GetProductById/GetProductByIdQuery.cs`

```csharp
public sealed record GetProductByIdQuery(Guid Id) : IRequest<ProductDto?>;
```

**File:** `Features/Catalog/Application/Queries/GetProductById/GetProductByIdQueryHandler.cs`

```csharp
public sealed class GetProductByIdQueryHandler
    : IRequestHandler<GetProductByIdQuery, ProductDto?>
{
    private readonly CatalogDbContext _context;

    public GetProductByIdQueryHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<ProductDto?> Handle(
        GetProductByIdQuery request,
        CancellationToken cancellationToken)
    {
        var product = await _context.Products
            .AsNoTracking()
            .Include(p => p.Category)
            .Where(p => p.Id == new ProductId(request.Id))
            .Select(p => new ProductDto(
                p.Id.Value,
                p.Name.Value,
                p.Description,
                p.Price.Amount,
                p.Price.Currency,
                p.ImageUrl,
                p.Sku,
                p.Status.ToString(),
                p.CategoryId.Value,
                p.Category!.Name.Value,
                p.CreatedAt,
                p.UpdatedAt))
            .FirstOrDefaultAsync(cancellationToken);

        return product;
    }
}
```

**Verification:**
- [ ] Returns null if not found (handled by endpoint)
- [ ] Includes category name
- [ ] Uses projection (not loading full entity)
</task>

<task id="4" title="Create CreateProduct command">
Implement product creation with validation.

**File:** `Features/Catalog/Application/Commands/CreateProduct/CreateProductCommand.cs`

```csharp
public sealed record CreateProductCommand(
    string Name,
    string Description,
    decimal Price,
    Guid CategoryId,
    string? ImageUrl = null,
    string? Sku = null) : IRequest<Guid>;
```

**File:** `Features/Catalog/Application/Commands/CreateProduct/CreateProductCommandValidator.cs`

```csharp
public sealed class CreateProductCommandValidator
    : AbstractValidator<CreateProductCommand>
{
    public CreateProductCommandValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Product name is required.")
            .MinimumLength(2).WithMessage("Product name must be at least 2 characters.")
            .MaximumLength(200).WithMessage("Product name cannot exceed 200 characters.");

        RuleFor(x => x.Description)
            .NotEmpty().WithMessage("Description is required.")
            .MaximumLength(4000).WithMessage("Description cannot exceed 4000 characters.");

        RuleFor(x => x.Price)
            .GreaterThanOrEqualTo(0).WithMessage("Price must be zero or positive.");

        RuleFor(x => x.CategoryId)
            .NotEmpty().WithMessage("Category is required.");

        RuleFor(x => x.ImageUrl)
            .MaximumLength(2000).WithMessage("Image URL cannot exceed 2000 characters.")
            .Must(BeAValidUrl).WithMessage("Image URL must be a valid URL.")
            .When(x => !string.IsNullOrWhiteSpace(x.ImageUrl));

        RuleFor(x => x.Sku)
            .MaximumLength(50).WithMessage("SKU cannot exceed 50 characters.")
            .When(x => !string.IsNullOrWhiteSpace(x.Sku));
    }

    private static bool BeAValidUrl(string? url)
    {
        if (string.IsNullOrWhiteSpace(url)) return true;
        return Uri.TryCreate(url, UriKind.Absolute, out var result)
            && (result.Scheme == Uri.UriSchemeHttp || result.Scheme == Uri.UriSchemeHttps);
    }
}
```

**File:** `Features/Catalog/Application/Commands/CreateProduct/CreateProductCommandHandler.cs`

```csharp
public sealed class CreateProductCommandHandler
    : IRequestHandler<CreateProductCommand, Guid>
{
    private readonly CatalogDbContext _context;

    public CreateProductCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<Guid> Handle(
        CreateProductCommand request,
        CancellationToken cancellationToken)
    {
        // Verify category exists
        var categoryExists = await _context.Categories
            .AnyAsync(c => c.Id == new CategoryId(request.CategoryId), cancellationToken);

        if (!categoryExists)
        {
            throw new NotFoundException($"Category with ID {request.CategoryId} not found.");
        }

        var name = ProductName.Create(request.Name);
        var price = Money.Create(request.Price);

        var product = Product.Create(
            name,
            request.Description,
            price,
            new CategoryId(request.CategoryId),
            request.ImageUrl,
            request.Sku);

        _context.Products.Add(product);
        await _context.SaveChangesAsync(cancellationToken);

        return product.Id.Value;
    }
}
```

**Verification:**
- [ ] Validates all required fields
- [ ] Checks category exists before creating
- [ ] Returns created product ID
- [ ] Domain event raised via SaveChangesAsync
</task>

<task id="5" title="Create UpdateProduct command">
Implement product update.

**File:** `Features/Catalog/Application/Commands/UpdateProduct/UpdateProductCommand.cs`

```csharp
public sealed record UpdateProductCommand(
    Guid Id,
    string Name,
    string Description,
    decimal Price,
    Guid CategoryId,
    string? ImageUrl = null,
    string? Sku = null) : IRequest<bool>;
```

**File:** `Features/Catalog/Application/Commands/UpdateProduct/UpdateProductCommandValidator.cs`
(Same validation rules as CreateProductCommand, plus Id validation)

**File:** `Features/Catalog/Application/Commands/UpdateProduct/UpdateProductCommandHandler.cs`

```csharp
public sealed class UpdateProductCommandHandler
    : IRequestHandler<UpdateProductCommand, bool>
{
    private readonly CatalogDbContext _context;

    public UpdateProductCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<bool> Handle(
        UpdateProductCommand request,
        CancellationToken cancellationToken)
    {
        var product = await _context.Products
            .FirstOrDefaultAsync(p => p.Id == new ProductId(request.Id), cancellationToken);

        if (product is null)
        {
            throw new NotFoundException($"Product with ID {request.Id} not found.");
        }

        // Verify category exists
        var categoryExists = await _context.Categories
            .AnyAsync(c => c.Id == new CategoryId(request.CategoryId), cancellationToken);

        if (!categoryExists)
        {
            throw new NotFoundException($"Category with ID {request.CategoryId} not found.");
        }

        var name = ProductName.Create(request.Name);
        var price = Money.Create(request.Price);

        product.Update(
            name,
            request.Description,
            price,
            new CategoryId(request.CategoryId),
            request.ImageUrl,
            request.Sku);

        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }
}
```

**Verification:**
- [ ] Finds existing product or throws NotFoundException
- [ ] Validates category exists
- [ ] Calls domain Update method
- [ ] Domain event raised
</task>

<task id="6" title="Create ChangeProductStatus command">
Implement publish/unpublish functionality.

**File:** `Features/Catalog/Application/Commands/ChangeProductStatus/ChangeProductStatusCommand.cs`

```csharp
public sealed record ChangeProductStatusCommand(
    Guid Id,
    string Status) : IRequest<bool>;
```

**File:** `Features/Catalog/Application/Commands/ChangeProductStatus/ChangeProductStatusCommandValidator.cs`

```csharp
public sealed class ChangeProductStatusCommandValidator
    : AbstractValidator<ChangeProductStatusCommand>
{
    public ChangeProductStatusCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty().WithMessage("Product ID is required.");

        RuleFor(x => x.Status)
            .NotEmpty().WithMessage("Status is required.")
            .Must(BeAValidStatus).WithMessage("Status must be 'Draft' or 'Published'.");
    }

    private static bool BeAValidStatus(string status)
    {
        return status.Equals("Draft", StringComparison.OrdinalIgnoreCase) ||
               status.Equals("Published", StringComparison.OrdinalIgnoreCase);
    }
}
```

**File:** `Features/Catalog/Application/Commands/ChangeProductStatus/ChangeProductStatusCommandHandler.cs`

```csharp
public sealed class ChangeProductStatusCommandHandler
    : IRequestHandler<ChangeProductStatusCommand, bool>
{
    private readonly CatalogDbContext _context;

    public ChangeProductStatusCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<bool> Handle(
        ChangeProductStatusCommand request,
        CancellationToken cancellationToken)
    {
        var product = await _context.Products
            .FirstOrDefaultAsync(p => p.Id == new ProductId(request.Id), cancellationToken);

        if (product is null)
        {
            throw new NotFoundException($"Product with ID {request.Id} not found.");
        }

        if (request.Status.Equals("Published", StringComparison.OrdinalIgnoreCase))
        {
            product.Publish();
        }
        else
        {
            product.Unpublish();
        }

        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }
}
```

**Verification:**
- [ ] Validates status is Draft or Published
- [ ] Calls appropriate domain method
- [ ] Domain event raised for status change
</task>

<task id="7" title="Create ArchiveProduct command">
Implement soft delete (archive) functionality.

**File:** `Features/Catalog/Application/Commands/ArchiveProduct/ArchiveProductCommand.cs`

```csharp
public sealed record ArchiveProductCommand(Guid Id) : IRequest<bool>;
```

**File:** `Features/Catalog/Application/Commands/ArchiveProduct/ArchiveProductCommandHandler.cs`

```csharp
public sealed class ArchiveProductCommandHandler
    : IRequestHandler<ArchiveProductCommand, bool>
{
    private readonly CatalogDbContext _context;

    public ArchiveProductCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<bool> Handle(
        ArchiveProductCommand request,
        CancellationToken cancellationToken)
    {
        var product = await _context.Products
            .FirstOrDefaultAsync(p => p.Id == new ProductId(request.Id), cancellationToken);

        if (product is null)
        {
            throw new NotFoundException($"Product with ID {request.Id} not found.");
        }

        product.Archive();

        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }
}
```

**Verification:**
- [ ] Finds product or throws NotFoundException
- [ ] Calls Archive() domain method
- [ ] ProductArchivedDomainEvent raised
</task>

<task id="8" title="Wire up Product endpoints">
Add all Product endpoints to CatalogEndpoints.

**Update:** `Features/Catalog/CatalogEndpoints.cs`

Add to existing MapCatalogEndpoints method:

```csharp
// Products
group.MapGet("/products", GetProducts)
    .WithName("GetProducts")
    .Produces<ProductListDto>();

group.MapGet("/products/{id:guid}", GetProductById)
    .WithName("GetProductById")
    .Produces<ProductDto>()
    .ProducesProblem(StatusCodes.Status404NotFound);

group.MapPost("/products", CreateProduct)
    .WithName("CreateProduct")
    .Produces<CreateProductResponse>(StatusCodes.Status201Created)
    .ProducesValidationProblem();

group.MapPut("/products/{id:guid}", UpdateProduct)
    .WithName("UpdateProduct")
    .Produces(StatusCodes.Status204NoContent)
    .ProducesValidationProblem()
    .ProducesProblem(StatusCodes.Status404NotFound);

group.MapPatch("/products/{id:guid}/status", ChangeProductStatus)
    .WithName("ChangeProductStatus")
    .Produces(StatusCodes.Status204NoContent)
    .ProducesValidationProblem()
    .ProducesProblem(StatusCodes.Status404NotFound);

group.MapDelete("/products/{id:guid}", ArchiveProduct)
    .WithName("ArchiveProduct")
    .Produces(StatusCodes.Status204NoContent)
    .ProducesProblem(StatusCodes.Status404NotFound);

// Endpoint handlers
private static async Task<IResult> GetProducts(
    [AsParameters] GetProductsQuery query,
    ISender sender,
    CancellationToken cancellationToken)
{
    var result = await sender.Send(query, cancellationToken);
    return Results.Ok(result);
}

private static async Task<IResult> GetProductById(
    Guid id,
    ISender sender,
    CancellationToken cancellationToken)
{
    var result = await sender.Send(new GetProductByIdQuery(id), cancellationToken);
    return result is null ? Results.NotFound() : Results.Ok(result);
}

private static async Task<IResult> CreateProduct(
    CreateProductRequest request,
    ISender sender,
    CancellationToken cancellationToken)
{
    var command = new CreateProductCommand(
        request.Name,
        request.Description,
        request.Price,
        request.CategoryId,
        request.ImageUrl,
        request.Sku);

    var productId = await sender.Send(command, cancellationToken);

    return Results.Created(
        $"/api/catalog/products/{productId}",
        new CreateProductResponse(productId));
}

private static async Task<IResult> UpdateProduct(
    Guid id,
    UpdateProductRequest request,
    ISender sender,
    CancellationToken cancellationToken)
{
    var command = new UpdateProductCommand(
        id,
        request.Name,
        request.Description,
        request.Price,
        request.CategoryId,
        request.ImageUrl,
        request.Sku);

    await sender.Send(command, cancellationToken);

    return Results.NoContent();
}

private static async Task<IResult> ChangeProductStatus(
    Guid id,
    ChangeProductStatusRequest request,
    ISender sender,
    CancellationToken cancellationToken)
{
    var command = new ChangeProductStatusCommand(id, request.Status);
    await sender.Send(command, cancellationToken);

    return Results.NoContent();
}

private static async Task<IResult> ArchiveProduct(
    Guid id,
    ISender sender,
    CancellationToken cancellationToken)
{
    await sender.Send(new ArchiveProductCommand(id), cancellationToken);
    return Results.NoContent();
}
```

**Request/Response records (add to CatalogEndpoints.cs or separate file):**

```csharp
public sealed record CreateProductRequest(
    string Name,
    string Description,
    decimal Price,
    Guid CategoryId,
    string? ImageUrl,
    string? Sku);

public sealed record CreateProductResponse(Guid Id);

public sealed record UpdateProductRequest(
    string Name,
    string Description,
    decimal Price,
    Guid CategoryId,
    string? ImageUrl,
    string? Sku);

public sealed record ChangeProductStatusRequest(string Status);
```

**Verification:**
- [ ] All 6 endpoints registered
- [ ] Correct HTTP methods (GET, POST, PUT, PATCH, DELETE)
- [ ] Correct status codes returned
- [ ] Query parameters work for GetProducts
</task>

## Verification Criteria

1. **All endpoints work:**
   - GET /api/catalog/products returns paginated list
   - GET /api/catalog/products/{id} returns single product
   - POST /api/catalog/products creates product
   - PUT /api/catalog/products/{id} updates product
   - PATCH /api/catalog/products/{id}/status changes status
   - DELETE /api/catalog/products/{id} archives product

2. **Validation works:**
   - Invalid requests return 400 with validation errors
   - Missing category returns 404

3. **Domain events fire:**
   - ProductCreated on create
   - ProductUpdated on update
   - ProductStatusChanged on status change
   - ProductArchived on delete

## Dependencies

- Plan 02-01 (Product domain model)
- Phase 1 infrastructure (MediatR, validation pipeline)

## Notes

- DELETE is soft delete (archive), not hard delete
- PATCH for status change follows REST conventions
- GetProducts supports filtering but not sorting (can add later)
- All handlers throw NotFoundException (handled by GlobalExceptionHandler)

