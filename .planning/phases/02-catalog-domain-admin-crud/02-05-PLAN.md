---
phase: 02-catalog-domain-admin-crud
plan: 05
title: Admin UI - Product List & Table
wave: 2
depends_on: [02-01, 02-02, 02-03]
files_modified:
  - code/MicroCommerce.Web/package.json
  - code/MicroCommerce.Web/src/app/admin/layout.tsx
  - code/MicroCommerce.Web/src/app/admin/products/page.tsx
  - code/MicroCommerce.Web/src/components/ui/*.tsx
  - code/MicroCommerce.Web/src/lib/api.ts
autonomous: true
estimated_duration: 25min
must_haves:
  - shadcn/ui installed and configured
  - Admin layout with navigation
  - Product list page at /admin/products
  - Data table with columns (image, name, category, price, status, actions)
  - Search input for filtering
  - Category and status filter dropdowns
  - Pagination controls
  - Loading and empty states
---

# Plan 02-05: Admin UI - Product List & Table

**Objective:** Build the admin product list page with data table, filters, and pagination using shadcn/ui components.

## Context

Per user vision (02-CONTEXT.md):
- Table-based list with search and filters
- Columns: Image, Name, Category, Price, Status, Actions
- Filter by category and status
- Search by name/description/SKU

This plan creates the foundation admin UI. The drawer for create/edit is in the next plan.

## Tasks

<task id="1" title="Install and configure shadcn/ui">
Set up shadcn/ui in the Next.js project.

**Run in MicroCommerce.Web directory:**

```bash
cd code/MicroCommerce.Web
npx shadcn@latest init --yes
```

When prompted:
- Style: Default
- Base color: Neutral
- CSS variables: Yes

**Install required components:**

```bash
npx shadcn@latest add button --yes
npx shadcn@latest add input --yes
npx shadcn@latest add select --yes
npx shadcn@latest add table --yes
npx shadcn@latest add badge --yes
npx shadcn@latest add skeleton --yes
npx shadcn@latest add dropdown-menu --yes
npx shadcn@latest add avatar --yes
```

**Verification:**
- [ ] components.json created
- [ ] src/components/ui/ has component files
- [ ] Tailwind config updated with shadcn
- [ ] globals.css has CSS variables
</task>

<task id="2" title="Create API client functions">
Create typed API functions for catalog endpoints.

**File:** `src/lib/api.ts`

```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';

export interface ProductDto {
  id: string;
  name: string;
  description: string;
  price: number;
  priceCurrency: string;
  imageUrl: string | null;
  sku: string | null;
  status: 'Draft' | 'Published' | 'Archived';
  categoryId: string;
  categoryName: string;
  createdAt: string;
  updatedAt: string | null;
}

export interface ProductListDto {
  items: ProductDto[];
  totalCount: number;
  page: number;
  pageSize: number;
}

export interface CategoryDto {
  id: string;
  name: string;
  description: string | null;
  createdAt: string;
}

export interface GetProductsParams {
  page?: number;
  pageSize?: number;
  categoryId?: string;
  status?: string;
  search?: string;
}

export async function getProducts(params: GetProductsParams = {}): Promise<ProductListDto> {
  const searchParams = new URLSearchParams();
  if (params.page) searchParams.set('page', params.page.toString());
  if (params.pageSize) searchParams.set('pageSize', params.pageSize.toString());
  if (params.categoryId) searchParams.set('categoryId', params.categoryId);
  if (params.status) searchParams.set('status', params.status);
  if (params.search) searchParams.set('search', params.search);

  const response = await fetch(`${API_BASE}/api/catalog/products?${searchParams}`, {
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error('Failed to fetch products');
  }

  return response.json();
}

export async function getCategories(): Promise<CategoryDto[]> {
  const response = await fetch(`${API_BASE}/api/catalog/categories`, {
    cache: 'no-store',
  });

  if (!response.ok) {
    throw new Error('Failed to fetch categories');
  }

  return response.json();
}

export async function changeProductStatus(id: string, status: string): Promise<void> {
  const response = await fetch(`${API_BASE}/api/catalog/products/${id}/status`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ status }),
  });

  if (!response.ok) {
    throw new Error('Failed to change product status');
  }
}

export async function archiveProduct(id: string): Promise<void> {
  const response = await fetch(`${API_BASE}/api/catalog/products/${id}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error('Failed to archive product');
  }
}
```

**Verification:**
- [ ] All types match backend DTOs
- [ ] getProducts supports all filter params
- [ ] Error handling in place
</task>

<task id="3" title="Create admin layout">
Create layout with navigation for admin section.

**File:** `src/app/admin/layout.tsx`

```tsx
import Link from 'next/link';
import { Package, FolderTree, LayoutDashboard } from 'lucide-react';

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-gray-50">
      {/* Top nav */}
      <header className="bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex">
              <div className="flex-shrink-0 flex items-center">
                <Link href="/admin" className="text-xl font-bold text-gray-900">
                  MicroCommerce Admin
                </Link>
              </div>
              <nav className="hidden sm:ml-8 sm:flex sm:space-x-8">
                <Link
                  href="/admin"
                  className="inline-flex items-center px-1 pt-1 text-sm font-medium text-gray-500 hover:text-gray-900"
                >
                  <LayoutDashboard className="w-4 h-4 mr-2" />
                  Dashboard
                </Link>
                <Link
                  href="/admin/products"
                  className="inline-flex items-center px-1 pt-1 text-sm font-medium text-gray-500 hover:text-gray-900"
                >
                  <Package className="w-4 h-4 mr-2" />
                  Products
                </Link>
                <Link
                  href="/admin/categories"
                  className="inline-flex items-center px-1 pt-1 text-sm font-medium text-gray-500 hover:text-gray-900"
                >
                  <FolderTree className="w-4 h-4 mr-2" />
                  Categories
                </Link>
              </nav>
            </div>
          </div>
        </div>
      </header>

      {/* Main content */}
      <main className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
        {children}
      </main>
    </div>
  );
}
```

**Install lucide-react if not present:**
```bash
npm install lucide-react
```

**Verification:**
- [ ] Admin layout renders
- [ ] Navigation links work
- [ ] Responsive design
</task>

<task id="4" title="Create admin dashboard placeholder">
Create simple dashboard page.

**File:** `src/app/admin/page.tsx`

```tsx
export default function AdminDashboard() {
  return (
    <div>
      <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
      <p className="mt-2 text-gray-600">
        Welcome to MicroCommerce Admin. Use the navigation above to manage products and categories.
      </p>
    </div>
  );
}
```

**Verification:**
- [ ] /admin route renders dashboard
</task>

<task id="5" title="Create ProductsTable component">
Create reusable data table for products.

**File:** `src/components/admin/products-table.tsx`

```tsx
'use client';

import { useState } from 'react';
import Image from 'next/image';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { MoreHorizontal, Pencil, Archive, Eye, EyeOff } from 'lucide-react';
import { ProductDto, changeProductStatus, archiveProduct } from '@/lib/api';

interface ProductsTableProps {
  products: ProductDto[];
  onEdit: (product: ProductDto) => void;
  onRefresh: () => void;
}

export function ProductsTable({ products, onEdit, onRefresh }: ProductsTableProps) {
  const [loading, setLoading] = useState<string | null>(null);

  const handleStatusChange = async (product: ProductDto) => {
    const newStatus = product.status === 'Published' ? 'Draft' : 'Published';
    setLoading(product.id);
    try {
      await changeProductStatus(product.id, newStatus);
      onRefresh();
    } catch (error) {
      console.error('Failed to change status:', error);
    } finally {
      setLoading(null);
    }
  };

  const handleArchive = async (product: ProductDto) => {
    if (!confirm(`Are you sure you want to archive "${product.name}"?`)) return;
    setLoading(product.id);
    try {
      await archiveProduct(product.id);
      onRefresh();
    } catch (error) {
      console.error('Failed to archive:', error);
    } finally {
      setLoading(null);
    }
  };

  const formatPrice = (price: number, currency: string) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency,
    }).format(price);
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'Published':
        return <Badge className="bg-green-100 text-green-800">Published</Badge>;
      case 'Draft':
        return <Badge variant="secondary">Draft</Badge>;
      case 'Archived':
        return <Badge variant="outline" className="text-gray-500">Archived</Badge>;
      default:
        return <Badge>{status}</Badge>;
    }
  };

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="w-[80px]">Image</TableHead>
          <TableHead>Name</TableHead>
          <TableHead>Category</TableHead>
          <TableHead className="text-right">Price</TableHead>
          <TableHead>Status</TableHead>
          <TableHead className="w-[70px]">Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {products.map((product) => (
          <TableRow key={product.id}>
            <TableCell>
              {product.imageUrl ? (
                <Image
                  src={product.imageUrl}
                  alt={product.name}
                  width={48}
                  height={48}
                  className="rounded object-cover"
                />
              ) : (
                <div className="w-12 h-12 bg-gray-100 rounded flex items-center justify-center text-gray-400">
                  <Package className="w-6 h-6" />
                </div>
              )}
            </TableCell>
            <TableCell>
              <div>
                <div className="font-medium">{product.name}</div>
                {product.sku && (
                  <div className="text-sm text-gray-500">SKU: {product.sku}</div>
                )}
              </div>
            </TableCell>
            <TableCell>{product.categoryName}</TableCell>
            <TableCell className="text-right">
              {formatPrice(product.price, product.priceCurrency)}
            </TableCell>
            <TableCell>{getStatusBadge(product.status)}</TableCell>
            <TableCell>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    className="h-8 w-8 p-0"
                    disabled={loading === product.id}
                  >
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => onEdit(product)}>
                    <Pencil className="mr-2 h-4 w-4" />
                    Edit
                  </DropdownMenuItem>
                  {product.status !== 'Archived' && (
                    <DropdownMenuItem onClick={() => handleStatusChange(product)}>
                      {product.status === 'Published' ? (
                        <>
                          <EyeOff className="mr-2 h-4 w-4" />
                          Unpublish
                        </>
                      ) : (
                        <>
                          <Eye className="mr-2 h-4 w-4" />
                          Publish
                        </>
                      )}
                    </DropdownMenuItem>
                  )}
                  {product.status !== 'Archived' && (
                    <DropdownMenuItem
                      onClick={() => handleArchive(product)}
                      className="text-red-600"
                    >
                      <Archive className="mr-2 h-4 w-4" />
                      Archive
                    </DropdownMenuItem>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```

**Verification:**
- [ ] Table renders product data
- [ ] Status badges styled correctly
- [ ] Actions dropdown works
- [ ] Image placeholder for products without images
</task>

<task id="6" title="Create ProductFilters component">
Create filter controls for the product list.

**File:** `src/components/admin/product-filters.tsx`

```tsx
'use client';

import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Search } from 'lucide-react';
import { CategoryDto } from '@/lib/api';

interface ProductFiltersProps {
  categories: CategoryDto[];
  search: string;
  categoryId: string;
  status: string;
  onSearchChange: (value: string) => void;
  onCategoryChange: (value: string) => void;
  onStatusChange: (value: string) => void;
}

export function ProductFilters({
  categories,
  search,
  categoryId,
  status,
  onSearchChange,
  onCategoryChange,
  onStatusChange,
}: ProductFiltersProps) {
  return (
    <div className="flex flex-col sm:flex-row gap-4">
      <div className="relative flex-1">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
        <Input
          placeholder="Search products..."
          value={search}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-10"
        />
      </div>
      <Select value={categoryId} onValueChange={onCategoryChange}>
        <SelectTrigger className="w-full sm:w-[180px]">
          <SelectValue placeholder="All Categories" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All Categories</SelectItem>
          {categories.map((category) => (
            <SelectItem key={category.id} value={category.id}>
              {category.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      <Select value={status} onValueChange={onStatusChange}>
        <SelectTrigger className="w-full sm:w-[140px]">
          <SelectValue placeholder="All Status" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All Status</SelectItem>
          <SelectItem value="Draft">Draft</SelectItem>
          <SelectItem value="Published">Published</SelectItem>
          <SelectItem value="Archived">Archived</SelectItem>
        </SelectContent>
      </Select>
    </div>
  );
}
```

**Install shadcn select if not done:**
```bash
npx shadcn@latest add select --yes
```

**Verification:**
- [ ] Search input works
- [ ] Category dropdown populated
- [ ] Status dropdown works
- [ ] Responsive layout
</task>

<task id="7" title="Create Pagination component">
Create pagination controls.

**File:** `src/components/admin/pagination.tsx`

```tsx
'use client';

import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';

interface PaginationProps {
  page: number;
  pageSize: number;
  totalCount: number;
  onPageChange: (page: number) => void;
}

export function Pagination({ page, pageSize, totalCount, onPageChange }: PaginationProps) {
  const totalPages = Math.ceil(totalCount / pageSize);
  const startItem = (page - 1) * pageSize + 1;
  const endItem = Math.min(page * pageSize, totalCount);

  return (
    <div className="flex items-center justify-between">
      <div className="text-sm text-gray-500">
        Showing {startItem} to {endItem} of {totalCount} products
      </div>
      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(page - 1)}
          disabled={page <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
          Previous
        </Button>
        <span className="text-sm text-gray-600">
          Page {page} of {totalPages}
        </span>
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(page + 1)}
          disabled={page >= totalPages}
        >
          Next
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}
```

**Verification:**
- [ ] Shows current range
- [ ] Previous/Next buttons work
- [ ] Disabled at boundaries
</task>

<task id="8" title="Create Products page">
Assemble the complete products list page.

**File:** `src/app/admin/products/page.tsx`

```tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import { Plus } from 'lucide-react';
import { ProductsTable } from '@/components/admin/products-table';
import { ProductFilters } from '@/components/admin/product-filters';
import { Pagination } from '@/components/admin/pagination';
import { getProducts, getCategories, ProductDto, ProductListDto, CategoryDto } from '@/lib/api';

export default function ProductsPage() {
  const [products, setProducts] = useState<ProductListDto | null>(null);
  const [categories, setCategories] = useState<CategoryDto[]>([]);
  const [loading, setLoading] = useState(true);

  // Filter state
  const [search, setSearch] = useState('');
  const [categoryId, setCategoryId] = useState('all');
  const [status, setStatus] = useState('all');
  const [page, setPage] = useState(1);

  // Drawer state (for next plan)
  const [editingProduct, setEditingProduct] = useState<ProductDto | null>(null);
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);

  const fetchProducts = useCallback(async () => {
    setLoading(true);
    try {
      const data = await getProducts({
        page,
        pageSize: 20,
        categoryId: categoryId !== 'all' ? categoryId : undefined,
        status: status !== 'all' ? status : undefined,
        search: search || undefined,
      });
      setProducts(data);
    } catch (error) {
      console.error('Failed to fetch products:', error);
    } finally {
      setLoading(false);
    }
  }, [page, categoryId, status, search]);

  const fetchCategories = useCallback(async () => {
    try {
      const data = await getCategories();
      setCategories(data);
    } catch (error) {
      console.error('Failed to fetch categories:', error);
    }
  }, []);

  useEffect(() => {
    fetchCategories();
  }, [fetchCategories]);

  useEffect(() => {
    const debounce = setTimeout(() => {
      fetchProducts();
    }, search ? 300 : 0); // Debounce search

    return () => clearTimeout(debounce);
  }, [fetchProducts, search]);

  // Reset to page 1 when filters change
  useEffect(() => {
    setPage(1);
  }, [categoryId, status, search]);

  const handleEdit = (product: ProductDto) => {
    setEditingProduct(product);
    setIsDrawerOpen(true);
  };

  const handleAddNew = () => {
    setEditingProduct(null);
    setIsDrawerOpen(true);
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Products</h1>
          <p className="text-gray-500">Manage your product catalog</p>
        </div>
        <Button onClick={handleAddNew}>
          <Plus className="mr-2 h-4 w-4" />
          Add Product
        </Button>
      </div>

      {/* Filters */}
      <ProductFilters
        categories={categories}
        search={search}
        categoryId={categoryId}
        status={status}
        onSearchChange={setSearch}
        onCategoryChange={setCategoryId}
        onStatusChange={setStatus}
      />

      {/* Table */}
      <div className="bg-white rounded-lg border">
        {loading ? (
          <div className="p-6 space-y-4">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="flex items-center space-x-4">
                <Skeleton className="h-12 w-12 rounded" />
                <div className="space-y-2 flex-1">
                  <Skeleton className="h-4 w-[200px]" />
                  <Skeleton className="h-4 w-[100px]" />
                </div>
              </div>
            ))}
          </div>
        ) : products && products.items.length > 0 ? (
          <ProductsTable
            products={products.items}
            onEdit={handleEdit}
            onRefresh={fetchProducts}
          />
        ) : (
          <div className="p-12 text-center">
            <div className="text-gray-400 mb-4">
              <Package className="h-12 w-12 mx-auto" />
            </div>
            <h3 className="text-lg font-medium text-gray-900">No products found</h3>
            <p className="text-gray-500 mt-1">
              {search || categoryId !== 'all' || status !== 'all'
                ? 'Try adjusting your filters'
                : 'Get started by adding your first product'}
            </p>
            {!search && categoryId === 'all' && status === 'all' && (
              <Button onClick={handleAddNew} className="mt-4">
                <Plus className="mr-2 h-4 w-4" />
                Add Product
              </Button>
            )}
          </div>
        )}
      </div>

      {/* Pagination */}
      {products && products.totalCount > 0 && (
        <Pagination
          page={products.page}
          pageSize={products.pageSize}
          totalCount={products.totalCount}
          onPageChange={setPage}
        />
      )}

      {/* Drawer placeholder - implemented in next plan */}
      {/* <ProductDrawer
        open={isDrawerOpen}
        onClose={() => setIsDrawerOpen(false)}
        product={editingProduct}
        categories={categories}
        onSave={fetchProducts}
      /> */}
    </div>
  );
}

// Import Package icon for empty state
import { Package } from 'lucide-react';
```

**Verification:**
- [ ] Page loads at /admin/products
- [ ] Products displayed in table
- [ ] Filters work (search, category, status)
- [ ] Pagination works
- [ ] Loading skeleton shows during fetch
- [ ] Empty state shows when no products
- [ ] Add Product button visible
</task>

## Verification Criteria

1. **UI renders correctly:**
   - /admin shows dashboard
   - /admin/products shows product list
   - Navigation works between pages

2. **Data fetching works:**
   - Products load from API
   - Categories load for filter dropdown
   - Errors handled gracefully

3. **Filters work:**
   - Search filters by name/description/SKU
   - Category filter works
   - Status filter works
   - Filters reset page to 1

4. **Table interactions work:**
   - Actions dropdown opens
   - Edit triggers (drawer not implemented yet)
   - Status change works
   - Archive with confirmation works

5. **Pagination works:**
   - Previous/Next buttons work
   - Shows correct count
   - Disabled at boundaries

## Dependencies

- Plans 02-01, 02-02, 02-03 (API endpoints must exist)
- Next.js frontend (existing)

## Notes

- Using shadcn/ui for consistent, accessible components
- Debounced search to avoid excessive API calls
- Drawer implementation is in next plan (02-06)
- CORS must be configured on API for localhost:3000
- Image component needs next.config.ts update for external images

