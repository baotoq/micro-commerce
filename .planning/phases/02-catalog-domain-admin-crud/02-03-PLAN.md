---
phase: 02-catalog-domain-admin-crud
plan: 03
title: Azure Blob Storage Image Upload
wave: 1
depends_on: []
files_modified:
  - code/MicroCommerce.AppHost/AppHost.cs
  - code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/UploadProductImage/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
  - code/MicroCommerce.ApiService/Program.cs
autonomous: true
estimated_duration: 15min
must_haves:
  - Azure Blob Storage configured in Aspire AppHost (Azurite emulator)
  - Image upload endpoint that returns blob URL
  - Aspire.Azure.Storage.Blobs integration in ApiService
  - Blob container auto-creation on startup
  - File type validation (images only)
  - File size limit (5MB)
---

# Plan 02-03: Azure Blob Storage Image Upload

**Objective:** Configure Azure Blob Storage with Azurite emulator for local development and implement image upload endpoint.

## Context

Per user decision, product images will be uploaded to Azure Blob Storage. For local development, we'll use Azurite (Azure Storage emulator) via Aspire. The upload endpoint will:
1. Validate file is an image
2. Upload to blob storage
3. Return the blob URL for product creation/update

## Tasks

<task id="1" title="Add Azure Blob Storage to Aspire AppHost">
Configure Azurite emulator in AppHost.

**Update:** `code/MicroCommerce.AppHost/AppHost.cs`

```csharp
var builder = DistributedApplication.CreateBuilder(args);

// PostgreSQL with persistent data volume
var postgres = builder.AddPostgres("postgres")
    .WithDataVolume()
    .WithLifetime(ContainerLifetime.Persistent)
    .WithPgAdmin();

var appDb = postgres.AddDatabase("appdb");

// Azure Service Bus emulator for domain events
var messaging = builder.AddAzureServiceBus("messaging")
    .RunAsEmulator();

// Azure Blob Storage emulator for product images
var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator();

var blobs = storage.AddBlobs("blobs");

var keycloak = builder
    .AddKeycloak("keycloak", 8101)
    .WithDataVolume()
    .WithRealmImport("./Realms")
    .WithLifetime(ContainerLifetime.Persistent);

var apiService = builder.AddProject<Projects.MicroCommerce_ApiService>("apiservice")
    .WithReference(keycloak)
    .WithReference(appDb)
    .WithReference(messaging)
    .WithReference(blobs)  // Add blob storage reference
    .WithHttpHealthCheck("/health");

builder.AddJavaScriptApp("frontend", "../MicroCommerce.Web")
    .WithReference(apiService)
    .WithReference(keycloak)
    .WithHttpEndpoint(port: 3000, env: "PORT");

builder.Build().Run();
```

**Verification:**
- [ ] Azure Storage emulator added
- [ ] Blobs resource created from storage
- [ ] ApiService references blobs
</task>

<task id="2" title="Add Aspire Blob Storage package to ApiService">
Add the Aspire Azure Blob Storage integration.

**Update:** `code/MicroCommerce.ApiService/MicroCommerce.ApiService.csproj`

Add package reference:
```xml
<PackageReference Include="Aspire.Azure.Storage.Blobs" Version="9.1.0" />
```

**Run:**
```bash
cd code/MicroCommerce.ApiService
dotnet restore
```

**Verification:**
- [ ] Package added to csproj
- [ ] Restore succeeds
</task>

<task id="3" title="Configure Blob Storage client in Program.cs">
Register BlobServiceClient with Aspire integration.

**Update:** `code/MicroCommerce.ApiService/Program.cs`

Add after other Aspire integrations:

```csharp
// Azure Blob Storage for product images
builder.AddAzureBlobClient("blobs");
```

**Verification:**
- [ ] BlobServiceClient registered via Aspire
- [ ] Connection string auto-configured from Aspire
</task>

<task id="4" title="Create ImageUploadService">
Create service to handle blob operations with container auto-creation.

**File:** `Features/Catalog/Infrastructure/ImageUploadService.cs`

```csharp
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;

namespace MicroCommerce.ApiService.Features.Catalog.Infrastructure;

public interface IImageUploadService
{
    Task<string> UploadImageAsync(Stream imageStream, string fileName, string contentType, CancellationToken cancellationToken = default);
}

public class ImageUploadService : IImageUploadService
{
    private readonly BlobServiceClient _blobServiceClient;
    private const string ContainerName = "product-images";

    public ImageUploadService(BlobServiceClient blobServiceClient)
    {
        _blobServiceClient = blobServiceClient;
    }

    public async Task<string> UploadImageAsync(
        Stream imageStream,
        string fileName,
        string contentType,
        CancellationToken cancellationToken = default)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(ContainerName);

        // Create container if it doesn't exist (with public access for images)
        await containerClient.CreateIfNotExistsAsync(
            PublicAccessType.Blob,
            cancellationToken: cancellationToken);

        // Generate unique blob name
        var blobName = $"{Guid.NewGuid()}{Path.GetExtension(fileName)}";
        var blobClient = containerClient.GetBlobClient(blobName);

        // Upload with content type
        await blobClient.UploadAsync(
            imageStream,
            new BlobHttpHeaders { ContentType = contentType },
            cancellationToken: cancellationToken);

        return blobClient.Uri.ToString();
    }
}
```

**Register in Program.cs:**
```csharp
builder.Services.AddScoped<IImageUploadService, ImageUploadService>();
```

**Verification:**
- [ ] Container created if not exists
- [ ] Unique blob name generated
- [ ] Content type set correctly
- [ ] Returns full blob URL
</task>

<task id="5" title="Create UploadProductImage command">
Implement image upload with validation.

**File:** `Features/Catalog/Application/Commands/UploadProductImage/UploadProductImageCommand.cs`

```csharp
public sealed record UploadProductImageCommand(
    Stream ImageStream,
    string FileName,
    string ContentType,
    long FileSize) : IRequest<string>;
```

**File:** `Features/Catalog/Application/Commands/UploadProductImage/UploadProductImageCommandValidator.cs`

```csharp
public sealed class UploadProductImageCommandValidator
    : AbstractValidator<UploadProductImageCommand>
{
    private static readonly string[] AllowedContentTypes =
    [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/webp"
    ];

    private const long MaxFileSize = 5 * 1024 * 1024; // 5MB

    public UploadProductImageCommandValidator()
    {
        RuleFor(x => x.FileName)
            .NotEmpty().WithMessage("File name is required.");

        RuleFor(x => x.ContentType)
            .NotEmpty().WithMessage("Content type is required.")
            .Must(BeAllowedContentType)
            .WithMessage($"File must be an image. Allowed types: {string.Join(", ", AllowedContentTypes)}");

        RuleFor(x => x.FileSize)
            .GreaterThan(0).WithMessage("File cannot be empty.")
            .LessThanOrEqualTo(MaxFileSize)
            .WithMessage($"File size cannot exceed {MaxFileSize / 1024 / 1024}MB.");
    }

    private static bool BeAllowedContentType(string contentType)
    {
        return AllowedContentTypes.Contains(contentType.ToLowerInvariant());
    }
}
```

**File:** `Features/Catalog/Application/Commands/UploadProductImage/UploadProductImageCommandHandler.cs`

```csharp
public sealed class UploadProductImageCommandHandler
    : IRequestHandler<UploadProductImageCommand, string>
{
    private readonly IImageUploadService _imageUploadService;

    public UploadProductImageCommandHandler(IImageUploadService imageUploadService)
    {
        _imageUploadService = imageUploadService;
    }

    public async Task<string> Handle(
        UploadProductImageCommand request,
        CancellationToken cancellationToken)
    {
        var imageUrl = await _imageUploadService.UploadImageAsync(
            request.ImageStream,
            request.FileName,
            request.ContentType,
            cancellationToken);

        return imageUrl;
    }
}
```

**Verification:**
- [ ] Validates content type is image
- [ ] Validates file size <= 5MB
- [ ] Returns blob URL
</task>

<task id="6" title="Add image upload endpoint">
Wire up the upload endpoint.

**Update:** `Features/Catalog/CatalogEndpoints.cs`

Add to MapCatalogEndpoints:

```csharp
// Image upload
group.MapPost("/images", UploadImage)
    .WithName("UploadProductImage")
    .Produces<UploadImageResponse>(StatusCodes.Status201Created)
    .ProducesValidationProblem()
    .DisableAntiforgery(); // Required for file uploads

// Handler
private static async Task<IResult> UploadImage(
    IFormFile file,
    ISender sender,
    CancellationToken cancellationToken)
{
    await using var stream = file.OpenReadStream();

    var command = new UploadProductImageCommand(
        stream,
        file.FileName,
        file.ContentType,
        file.Length);

    var imageUrl = await sender.Send(command, cancellationToken);

    return Results.Created(imageUrl, new UploadImageResponse(imageUrl));
}

// Response record
public sealed record UploadImageResponse(string ImageUrl);
```

**Verification:**
- [ ] POST /api/catalog/images endpoint works
- [ ] Accepts multipart/form-data
- [ ] Returns blob URL in response
- [ ] DisableAntiforgery() added for file upload
</task>

## Verification Criteria

1. **Aspire resources configured:**
   - `aspire run` shows storage emulator starting
   - Blob service accessible

2. **Upload works end-to-end:**
   - POST image to /api/catalog/images
   - Receive blob URL in response
   - URL is accessible (public blob)

3. **Validation enforced:**
   - Non-image files rejected
   - Files > 5MB rejected
   - Empty files rejected

## Dependencies

- Aspire AppHost (existing)
- No dependency on other Phase 2 plans (can run in parallel)

## Notes

- Using Azurite emulator for local dev (no Azure account needed)
- Container set to public access for simplicity (images are public)
- Blob names are GUIDs to prevent collisions
- In production, would add CDN and possibly resize images
- File validation happens in validator (before handler)

