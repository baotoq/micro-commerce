---
phase: 02-catalog-domain-admin-crud
plan: 01
title: Product Domain Model & CQRS Stack
wave: 1
depends_on: []
files_modified:
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/Entities/Product.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/ProductId.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/ProductName.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/Money.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/ValueObjects/ProductStatus.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Domain/Events/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/Configurations/ProductConfiguration.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Infrastructure/CatalogDbContext.cs
autonomous: true
estimated_duration: 15min
must_haves:
  - Product aggregate root with factory method and domain events
  - Strongly-typed ProductId with EF Core conversion
  - Money value object for price (decimal with currency)
  - ProductStatus enum (Draft, Published, Archived)
  - EF Core configuration with value object mappings
  - Product-Category relationship configured
---

# Plan 02-01: Product Domain Model & CQRS Stack

**Objective:** Create the Product aggregate root following established patterns from Category, with value objects, domain events, and EF Core configuration.

## Context

Phase 1 established the CQRS reference implementation with Category. This plan extends the Catalog domain with Product, following the same patterns:
- Factory methods for aggregate creation
- Thin domain events (ID only)
- Value objects with validation
- EF Core configurations with conversions

## Tasks

<task id="1" title="Create Product value objects">
Create strongly-typed ID and value objects for Product domain.

**Files to create:**

1. `Features/Catalog/Domain/ValueObjects/ProductId.cs`:
```csharp
// Follow CategoryId pattern - StronglyTypedId<ProductId>
// New() factory, Value property, implicit conversion to Guid
```

2. `Features/Catalog/Domain/ValueObjects/ProductName.cs`:
```csharp
// Follow CategoryName pattern - ValueObject
// Create() factory with validation (2-200 chars)
// Value property
```

3. `Features/Catalog/Domain/ValueObjects/Money.cs`:
```csharp
// New value object for price
// Amount (decimal), Currency (string, default "USD")
// Create() factory with validation (amount >= 0)
// Formatting method for display
```

4. `Features/Catalog/Domain/ValueObjects/ProductStatus.cs`:
```csharp
// Enum: Draft = 0, Published = 1, Archived = 2
```

**Reference:** `Features/Catalog/Domain/ValueObjects/CategoryId.cs` and `CategoryName.cs`

**Verification:**
- [ ] ProductId has New() and implicit Guid conversion
- [ ] ProductName validates length 2-200
- [ ] Money validates amount >= 0
- [ ] ProductStatus has three states
</task>

<task id="2" title="Create Product domain events">
Create thin domain events for Product lifecycle.

**Files to create in `Features/Catalog/Domain/Events/`:**

1. `ProductCreatedDomainEvent.cs`:
```csharp
public sealed record ProductCreatedDomainEvent : DomainEvent
{
    public Guid ProductId { get; }
    public ProductCreatedDomainEvent(ProductId productId)
    {
        ProductId = productId.Value;
    }
}
```

2. `ProductUpdatedDomainEvent.cs` - same pattern

3. `ProductStatusChangedDomainEvent.cs`:
```csharp
// Include ProductId and NewStatus (as string for serialization)
```

4. `ProductArchivedDomainEvent.cs` - for soft delete tracking

**Reference:** `Features/Catalog/Domain/Events/CategoryCreatedDomainEvent.cs`

**Verification:**
- [ ] All events inherit from DomainEvent
- [ ] Events contain only IDs (thin events pattern)
- [ ] Guid used for serialization (not strongly-typed ID)
</task>

<task id="3" title="Create Product aggregate root">
Create Product entity following Category pattern with factory methods.

**File:** `Features/Catalog/Domain/Entities/Product.cs`

```csharp
public sealed class Product : BaseAggregateRoot<ProductId>
{
    public ProductName Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public Money Price { get; private set; } = null!;
    public string? ImageUrl { get; private set; }
    public string? Sku { get; private set; }
    public ProductStatus Status { get; private set; }
    public CategoryId CategoryId { get; private set; } = null!;
    public Category? Category { get; private set; }
    public DateTimeOffset CreatedAt { get; private set; }
    public DateTimeOffset? UpdatedAt { get; private set; }

    // EF Core constructor
    private Product(ProductId id) : base(id) { }

    // Factory method - raises ProductCreatedDomainEvent
    public static Product Create(
        ProductName name,
        string description,
        Money price,
        CategoryId categoryId,
        string? imageUrl = null,
        string? sku = null)
    {
        var product = new Product(ProductId.New())
        {
            Name = name,
            Description = description.Trim(),
            Price = price,
            CategoryId = categoryId,
            ImageUrl = imageUrl,
            Sku = sku?.Trim(),
            Status = ProductStatus.Draft,
            CreatedAt = DateTimeOffset.UtcNow
        };

        product.AddDomainEvent(new ProductCreatedDomainEvent(product.Id));
        return product;
    }

    // Update methods that raise events
    public void Update(ProductName name, string description, Money price, CategoryId categoryId, string? imageUrl, string? sku)
    {
        Name = name;
        Description = description.Trim();
        Price = price;
        CategoryId = categoryId;
        ImageUrl = imageUrl;
        Sku = sku?.Trim();
        UpdatedAt = DateTimeOffset.UtcNow;
        AddDomainEvent(new ProductUpdatedDomainEvent(Id));
    }

    public void Publish()
    {
        if (Status == ProductStatus.Published) return;
        Status = ProductStatus.Published;
        UpdatedAt = DateTimeOffset.UtcNow;
        AddDomainEvent(new ProductStatusChangedDomainEvent(Id, Status));
    }

    public void Unpublish()
    {
        if (Status == ProductStatus.Draft) return;
        Status = ProductStatus.Draft;
        UpdatedAt = DateTimeOffset.UtcNow;
        AddDomainEvent(new ProductStatusChangedDomainEvent(Id, Status));
    }

    public void Archive()
    {
        if (Status == ProductStatus.Archived) return;
        Status = ProductStatus.Archived;
        UpdatedAt = DateTimeOffset.UtcNow;
        AddDomainEvent(new ProductArchivedDomainEvent(Id));
    }
}
```

**Verification:**
- [ ] Inherits BaseAggregateRoot<ProductId>
- [ ] Factory method Create() raises event
- [ ] State change methods raise appropriate events
- [ ] All setters are private
- [ ] Navigation property to Category
</task>

<task id="4" title="Create EF Core configuration">
Configure Product entity with value object conversions and relationships.

**File:** `Features/Catalog/Infrastructure/Configurations/ProductConfiguration.cs`

```csharp
public class ProductConfiguration : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        builder.ToTable("Products");

        builder.HasKey(p => p.Id);

        // ProductId conversion
        builder.Property(p => p.Id)
            .HasConversion(
                id => id.Value,
                value => new ProductId(value));

        // ProductName value object
        builder.Property(p => p.Name)
            .HasConversion(
                name => name.Value,
                value => ProductName.Create(value))
            .HasMaxLength(200)
            .IsRequired();

        // Money value object (complex type or owned entity)
        builder.OwnsOne(p => p.Price, priceBuilder =>
        {
            priceBuilder.Property(m => m.Amount)
                .HasColumnName("Price")
                .HasPrecision(18, 2)
                .IsRequired();

            priceBuilder.Property(m => m.Currency)
                .HasColumnName("PriceCurrency")
                .HasMaxLength(3)
                .HasDefaultValue("USD")
                .IsRequired();
        });

        builder.Property(p => p.Description)
            .HasMaxLength(4000)
            .IsRequired();

        builder.Property(p => p.ImageUrl)
            .HasMaxLength(2000);

        builder.Property(p => p.Sku)
            .HasMaxLength(50);

        builder.Property(p => p.Status)
            .HasConversion<string>()
            .HasMaxLength(20)
            .IsRequired();

        // CategoryId conversion
        builder.Property(p => p.CategoryId)
            .HasConversion(
                id => id.Value,
                value => new CategoryId(value))
            .IsRequired();

        // Relationship to Category
        builder.HasOne(p => p.Category)
            .WithMany()
            .HasForeignKey(p => p.CategoryId)
            .OnDelete(DeleteBehavior.Restrict);

        builder.Property(p => p.CreatedAt).IsRequired();

        // Indexes
        builder.HasIndex(p => p.CategoryId);
        builder.HasIndex(p => p.Status);
        builder.HasIndex(p => p.Sku).IsUnique().HasFilter("\"Sku\" IS NOT NULL");
    }
}
```

**Verification:**
- [ ] All value objects have conversions
- [ ] Money is owned entity with Amount and Currency columns
- [ ] Foreign key to Category configured
- [ ] Indexes on CategoryId, Status, Sku
</task>

<task id="5" title="Update CatalogDbContext and create migration">
Add Products DbSet and generate migration.

**Update:** `Features/Catalog/Infrastructure/CatalogDbContext.cs`
```csharp
public DbSet<Product> Products => Set<Product>();
```

**Run migration:**
```bash
cd code/MicroCommerce.ApiService
dotnet ef migrations add AddProducts --context CatalogDbContext --output-dir Features/Catalog/Infrastructure/Migrations
```

**Verification:**
- [ ] Products DbSet added to CatalogDbContext
- [ ] Migration generated successfully
- [ ] Migration creates Products table in catalog schema
- [ ] Foreign key constraint to Categories table
</task>

## Verification Criteria

1. **Domain model complete:**
   - Product aggregate with all value objects compiles
   - Domain events defined for all lifecycle changes
   - Factory method enforces invariants

2. **EF Core mapping works:**
   - Migration generates correct SQL
   - Value objects map to appropriate column types
   - Relationships configured correctly

3. **Follows established patterns:**
   - Matches Category implementation style
   - Uses thin domain events
   - Private setters, factory methods

## Dependencies

- Phase 1 complete (Category, BaseAggregateRoot, DomainEvent infrastructure)
- No external dependencies

## Notes

- Money value object uses owned entity pattern for EF Core (Amount + Currency columns)
- ProductStatus stored as string for readability in database
- SKU index is unique but filtered (allows multiple NULLs)
- Soft delete via Archive() method (status change, not actual delete)

