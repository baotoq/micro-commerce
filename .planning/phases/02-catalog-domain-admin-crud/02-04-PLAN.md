---
phase: 02-catalog-domain-admin-crud
plan: 04
title: Category CRUD Completion
wave: 1
depends_on: []
files_modified:
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/UpdateCategory/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Commands/DeleteCategory/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/Application/Queries/GetCategoryById/*.cs
  - code/MicroCommerce.ApiService/Features/Catalog/CatalogEndpoints.cs
autonomous: true
estimated_duration: 10min
must_haves:
  - UpdateCategory command with validation
  - DeleteCategory command (soft delete or restrict if products exist)
  - GetCategoryById query
  - All category endpoints complete (GET by id, PUT, DELETE)
---

# Plan 02-04: Category CRUD Completion

**Objective:** Complete the Category CRUD operations that were started in Phase 1 as a reference implementation.

## Context

Phase 1 created Category with:
- Create command + handler + validator
- GetCategories query (list all)
- POST and GET endpoints

This plan adds the missing operations:
- Update command
- Delete command (with product check)
- GetById query
- PUT, DELETE, GET by id endpoints

## Tasks

<task id="1" title="Create GetCategoryById query">
Implement single category retrieval.

**File:** `Features/Catalog/Application/Queries/GetCategoryById/GetCategoryByIdQuery.cs`

```csharp
public sealed record GetCategoryByIdQuery(Guid Id) : IRequest<CategoryDto?>;
```

**File:** `Features/Catalog/Application/Queries/GetCategoryById/GetCategoryByIdQueryHandler.cs`

```csharp
public sealed class GetCategoryByIdQueryHandler
    : IRequestHandler<GetCategoryByIdQuery, CategoryDto?>
{
    private readonly CatalogDbContext _context;

    public GetCategoryByIdQueryHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<CategoryDto?> Handle(
        GetCategoryByIdQuery request,
        CancellationToken cancellationToken)
    {
        var category = await _context.Categories
            .AsNoTracking()
            .Where(c => c.Id == new CategoryId(request.Id))
            .Select(c => new CategoryDto(
                c.Id.Value,
                c.Name.Value,
                c.Description,
                c.CreatedAt))
            .FirstOrDefaultAsync(cancellationToken);

        return category;
    }
}
```

**Verification:**
- [ ] Returns null if not found
- [ ] Uses projection (not loading full entity)
- [ ] Reuses existing CategoryDto
</task>

<task id="2" title="Add Update methods to Category entity">
Add update methods to Category aggregate if not already present.

**Check/Update:** `Features/Catalog/Domain/Entities/Category.cs`

Ensure these methods exist (may already be there from Phase 1):

```csharp
/// <summary>
/// Updates the category details.
/// </summary>
public void Update(CategoryName name, string? description)
{
    Name = name;
    Description = description?.Trim();
    UpdatedAt = DateTimeOffset.UtcNow;
    // Optionally add CategoryUpdatedDomainEvent
}
```

**Verification:**
- [ ] Update method exists on Category
- [ ] UpdatedAt is set
</task>

<task id="3" title="Create UpdateCategory command">
Implement category update.

**File:** `Features/Catalog/Application/Commands/UpdateCategory/UpdateCategoryCommand.cs`

```csharp
public sealed record UpdateCategoryCommand(
    Guid Id,
    string Name,
    string? Description = null) : IRequest<bool>;
```

**File:** `Features/Catalog/Application/Commands/UpdateCategory/UpdateCategoryCommandValidator.cs`

```csharp
public sealed class UpdateCategoryCommandValidator
    : AbstractValidator<UpdateCategoryCommand>
{
    public UpdateCategoryCommandValidator()
    {
        RuleFor(x => x.Id)
            .NotEmpty().WithMessage("Category ID is required.");

        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Category name is required.")
            .MinimumLength(2).WithMessage("Category name must be at least 2 characters.")
            .MaximumLength(100).WithMessage("Category name cannot exceed 100 characters.");

        RuleFor(x => x.Description)
            .MaximumLength(500).WithMessage("Description cannot exceed 500 characters.")
            .When(x => x.Description is not null);
    }
}
```

**File:** `Features/Catalog/Application/Commands/UpdateCategory/UpdateCategoryCommandHandler.cs`

```csharp
public sealed class UpdateCategoryCommandHandler
    : IRequestHandler<UpdateCategoryCommand, bool>
{
    private readonly CatalogDbContext _context;

    public UpdateCategoryCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<bool> Handle(
        UpdateCategoryCommand request,
        CancellationToken cancellationToken)
    {
        var category = await _context.Categories
            .FirstOrDefaultAsync(c => c.Id == new CategoryId(request.Id), cancellationToken);

        if (category is null)
        {
            throw new NotFoundException($"Category with ID {request.Id} not found.");
        }

        var name = CategoryName.Create(request.Name);
        category.Update(name, request.Description);

        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }
}
```

**Verification:**
- [ ] Validates input
- [ ] Finds category or throws NotFoundException
- [ ] Calls domain Update method
</task>

<task id="4" title="Create DeleteCategory command">
Implement category deletion with product check.

**File:** `Features/Catalog/Application/Commands/DeleteCategory/DeleteCategoryCommand.cs`

```csharp
public sealed record DeleteCategoryCommand(Guid Id) : IRequest<bool>;
```

**File:** `Features/Catalog/Application/Commands/DeleteCategory/DeleteCategoryCommandHandler.cs`

```csharp
public sealed class DeleteCategoryCommandHandler
    : IRequestHandler<DeleteCategoryCommand, bool>
{
    private readonly CatalogDbContext _context;

    public DeleteCategoryCommandHandler(CatalogDbContext context)
    {
        _context = context;
    }

    public async Task<bool> Handle(
        DeleteCategoryCommand request,
        CancellationToken cancellationToken)
    {
        var category = await _context.Categories
            .FirstOrDefaultAsync(c => c.Id == new CategoryId(request.Id), cancellationToken);

        if (category is null)
        {
            throw new NotFoundException($"Category with ID {request.Id} not found.");
        }

        // Check if any products use this category
        var hasProducts = await _context.Products
            .AnyAsync(p => p.CategoryId == new CategoryId(request.Id), cancellationToken);

        if (hasProducts)
        {
            throw new ConflictException("Cannot delete category that has products. Remove or reassign products first.");
        }

        _context.Categories.Remove(category);
        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }
}
```

**Create ConflictException if not exists:**

**File:** `Common/Exceptions/ConflictException.cs`

```csharp
namespace MicroCommerce.ApiService.Common.Exceptions;

public class ConflictException : Exception
{
    public ConflictException(string message) : base(message)
    {
    }
}
```

**Update GlobalExceptionHandler to handle ConflictException:**

```csharp
ConflictException conflictException => (
    StatusCodes.Status409Conflict,
    "Conflict",
    conflictException.Message),
```

**Verification:**
- [ ] Finds category or throws NotFoundException
- [ ] Checks for products using category
- [ ] Throws ConflictException if products exist
- [ ] Hard deletes category (categories don't need soft delete)
</task>

<task id="5" title="Wire up remaining Category endpoints">
Add GET by id, PUT, and DELETE endpoints.

**Update:** `Features/Catalog/CatalogEndpoints.cs`

Add to existing category endpoints:

```csharp
// Categories (add to existing)
group.MapGet("/categories/{id:guid}", GetCategoryById)
    .WithName("GetCategoryById")
    .Produces<CategoryDto>()
    .ProducesProblem(StatusCodes.Status404NotFound);

group.MapPut("/categories/{id:guid}", UpdateCategory)
    .WithName("UpdateCategory")
    .Produces(StatusCodes.Status204NoContent)
    .ProducesValidationProblem()
    .ProducesProblem(StatusCodes.Status404NotFound);

group.MapDelete("/categories/{id:guid}", DeleteCategory)
    .WithName("DeleteCategory")
    .Produces(StatusCodes.Status204NoContent)
    .ProducesProblem(StatusCodes.Status404NotFound)
    .ProducesProblem(StatusCodes.Status409Conflict);

// Handlers
private static async Task<IResult> GetCategoryById(
    Guid id,
    ISender sender,
    CancellationToken cancellationToken)
{
    var result = await sender.Send(new GetCategoryByIdQuery(id), cancellationToken);
    return result is null ? Results.NotFound() : Results.Ok(result);
}

private static async Task<IResult> UpdateCategory(
    Guid id,
    UpdateCategoryRequest request,
    ISender sender,
    CancellationToken cancellationToken)
{
    var command = new UpdateCategoryCommand(id, request.Name, request.Description);
    await sender.Send(command, cancellationToken);
    return Results.NoContent();
}

private static async Task<IResult> DeleteCategory(
    Guid id,
    ISender sender,
    CancellationToken cancellationToken)
{
    await sender.Send(new DeleteCategoryCommand(id), cancellationToken);
    return Results.NoContent();
}

// Request record
public sealed record UpdateCategoryRequest(string Name, string? Description);
```

**Verification:**
- [ ] GET /api/catalog/categories/{id} returns category
- [ ] PUT /api/catalog/categories/{id} updates category
- [ ] DELETE /api/catalog/categories/{id} deletes category
- [ ] 409 Conflict returned when deleting category with products
</task>

## Verification Criteria

1. **All Category endpoints work:**
   - GET /api/catalog/categories (existing)
   - GET /api/catalog/categories/{id} (new)
   - POST /api/catalog/categories (existing)
   - PUT /api/catalog/categories/{id} (new)
   - DELETE /api/catalog/categories/{id} (new)

2. **Business rules enforced:**
   - Cannot delete category with products
   - Validation errors return 400
   - Not found returns 404
   - Conflict returns 409

## Dependencies

- Phase 1 Category implementation
- No dependency on other Phase 2 plans (can run in parallel)

## Notes

- Categories use hard delete (not soft delete like products)
- Delete is restricted if products exist (referential integrity)
- ConflictException added for 409 responses
- Follows same patterns as Product CRUD

